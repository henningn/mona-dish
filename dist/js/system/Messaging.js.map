{"version":3,"file":"Messaging.js","mappings":"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","sources":["webpack:///./src/main/typescript/Users/werpu2/development/workspace/monadish/src/main/typescript/Messaging.ts","webpack:///external \"rxjs\"","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"sourcesContent":["/**\n * a standardized message to be sent over the message bus\n */\nimport {Observable, Subject} from \"rxjs\";\n\n/**\n * generic crypto interface\n * to encrypt messages before they are sent\n * to the message bus oder the underlying bus system\n *\n * The idea is to make it as easy as possible, you can use for instance crypto js to\n * handle everything\n */\nexport interface Crypto {\n    /**\n     * note anything can be passed\n     *\n     * @param data the data to be encrypted\n     * @returns the encrypted data in any format, important is decode must be able to handle it\n     */\n    encode(data: any): any;\n\n    /**\n     * @param data the encrypted data in the format you expect it to be\n     * @returns the unencrypted data\n     */\n    decode(data: any): any;\n}\n\n\n/**\n * generic hash interface which provides\n * exactly one method a hash encode which returns a string hash value of encoded data\n */\nexport interface Hash {\n    encode(encodedData: string): string;\n}\n\n/**\n * Default implementation = no encryption\n */\nexport class NoCrypto implements Crypto {\n    decode(data: any): string {\n        return data;\n    }\n\n    encode(data: any): any {\n        return data;\n    }\n}\n\n//TODO dynamic encryptor which flushes the messages before changing the keys\n//that way we can rotate and change internal crypto keys on the fly\n\nlet noEncryption = new NoCrypto();\n\nexport class Message {\n\n    creationDate?: number;\n    identifier?: string;\n    targetOrigin?: string;\n    encoded: boolean = false;\n\n    constructor(public message: any = {}, targetOrigin = \"*\") {\n        this.targetOrigin = targetOrigin;\n        this.creationDate = new Date().getMilliseconds();\n        this.identifier = new Date().getMilliseconds() + \"_\" + Math.random() + \"_\" + Math.random();\n    }\n}\n\n/**\n * custom dom event wrapping our messages\n */\nclass MessageWrapper implements CustomEventInit<Message> {\n\n    detail?: Message;\n    bubbles?: boolean;\n    cancelable?: boolean;\n    composed?: boolean;\n    channel: string;\n\n    constructor(channel: string, message: Message) {\n        this.detail = message;\n        this.bubbles = true;\n        this.cancelable = true;\n        this.composed = true;\n        this.channel = channel;\n    }\n}\n\n\nabstract class BaseBroker {\n\n    static readonly EVENT_TYPE = \"brokerEvent\";\n    /**\n     * we can split the listeners with the system\n     * namespace... and type (aka identifier criteria)\n     */\n    protected messageListeners: any = {};\n    protected subjects: any = {};\n    protected processedMessages: any = {};\n\n    protected cleanupCnt = 0;\n    protected rootElem;\n    protected msgHandler;\n\n    protected readonly TIMEOUT_IN_MS = 1000;\n    protected readonly MSG_EVENT = \"message\";\n\n    //must be public because we also must have the option\n    //to set it outside of the constructor\n    crypto = noEncryption;\n\n\n    abstract register(scopeElement?: any);\n\n    abstract unregister();\n\n    abstract broadcast(channel: string, message: Message | string);\n\n\n    /**\n     * registers a listener on a channel\n     * @param channel the channel to register the listeners for\n     * @param listener the listener to register\n     */\n    registerListener(channel: string, listener: (msg: Message) => void) {\n        this.reserveListenerNS(channel);\n\n        //we skip the processed messages, because they originated here\n        //and already are processed\n        this.messageListeners[channel].push((msg: Message) => {\n            if (msg.identifier in this.processedMessages) {\n                return;\n            }\n            if(msg?.encoded || msg?.[\"detail\"]?.encoded) {\n                if(msg?.[\"detail\"]) {\n                    msg[\"detail\"].message = this.crypto.decode(msg[\"detail\"].message);\n                    msg[\"detail\"].encoded = false;\n                } else {\n                    msg.message = this.crypto.decode(msg.message);\n                    msg.encoded = false;\n                }\n\n            }\n            listener(msg);\n        });\n    }\n\n    /**\n     * binding into rxjs\n     * produces a subject which can be used via next calls to send messages\n     * on the other hand we\n     * @param channel\n     */\n    asSubject(channel: string): Subject<Message> {\n        this.reserveSubjectNS(channel);\n        let subject = this.subjects[channel];\n        let oldNext = subject.next;\n\n        subject.next = (msg: Message | MessageWrapper) => {\n            //We use a recursive call to let the broadcaster handle\n            //The wrapper conversion and then again call us here\n            //that way both directions are handled.. next calls the broker\n            //and a broadcast calls next\n            if((<MessageWrapper>msg)?.detail) {\n                oldNext.call(subject, (<MessageWrapper>msg)?.detail);\n            } else {\n                this.broadcast(channel, <Message> msg);\n            }\n        }\n        return subject;\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * returns an observable on the baseBroker\n     * @param channel\n     */\n    asObservable(channel: string): Observable<Message> {\n        return this.asSubject(channel).asObservable();\n    }\n\n    /**\n     * reserves the listener namespace and wildcard namespace for the given identifier\n     * @param identifier\n     * @private\n     */\n    private reserveListenerNS(identifier: string) {\n        if (!this.messageListeners[identifier]) {\n            this.messageListeners[identifier] = [];\n        }\n        if (!this.messageListeners[\"*\"]) {\n            this.messageListeners[\"*\"] = [];\n        }\n    }\n\n    private reserveSubjectNS(identifier: string) {\n        if (!this.subjects[identifier]) {\n            this.subjects[identifier] = new Subject();\n        }\n        if (!this.subjects[\"*\"]) {\n            this.subjects[\"*\"] = new Subject();\n        }\n    }\n\n    /**\n     * unregisters a listener from this channel\n     *\n     * @param channel the channel to unregister from\n     * @param listener the listener to unregister the channel from\n     */\n    unregisterListener(channel: string, listener: (msg: Message) => void) {\n        this.messageListeners[channel] = (this.messageListeners[channel] || []).filter((item: any) => item !== listener);\n    }\n\n    /**\n     * answers a bidirectional message received\n     * usage, the client can use this method, to answer an incoming message in a precise manner\n     * so that the caller sending the bidirectional message knows how to deal with it\n     * this mechanism can be used for global storages where we have one answering entity per channel delivering the\n     * requested data, the request can be done asynchronously via promises waiting for answers\n     *\n     * @param channel the channel the originating message\n     * @param request the requesting message\n     * @param answer the answer to the request\n     */\n    answer(channel: string, request: Message |string, answer: Message) {\n        if('string' == typeof request) {\n            request = new Message(request);\n        }\n\n        if (BaseBroker.isAnswer(request)) {\n            return;\n        }\n        answer.identifier = BaseBroker.getAnswerId(request);\n        this.broadcast(channel, answer);\n    }\n\n    private static getAnswerId(request: Message) {\n        return \"_r_\" + request.identifier;\n    }\n\n    private static isAnswer(request: Message) {\n        return request.identifier.indexOf(\"_r_\") == 0;\n    }\n\n    /**\n     * idea... a bidirectional broadcast\n     * sends a message and waits for the first answer coming in from one of the receivers\n     * sending the message back with a messageIdentifier_broadCastId answer\n     *\n     * @param channel\n     * @param message\n     */\n    request(channel: string, message: Message | string): Promise<Message> {\n        if('string' == typeof message) {\n            message = new Message(message);\n        }\n        let messageId = message.identifier;\n\n        let ret = new Promise<Message>((resolve, reject) => {\n            let timeout = null;\n            let listener = (message2: Message) => {\n                if (message2.identifier == messageId) {\n                    //broadcast from same source, we do not want\n                    //to deal with it now\n                    return;\n                }\n\n                if (message2.identifier == \"_r_\" + messageId) {\n                    clearTimeout(timeout);\n                    this.unregisterListener(channel, listener);\n                    resolve(message2);\n                }\n            }\n            timeout = setTimeout(() => {\n                this.unregisterListener(channel, listener);\n                reject(\"request message performed, timeout, no return value\");\n            }, 3000);\n            this.registerListener(channel, listener);\n\n        });\n        this.broadcast(channel, message);\n        return ret;\n    }\n\n\n    /**\n     * garbage collects the processed messages queue\n     * usually after one second\n     */\n    protected gcProcessedMessages() {\n        if ((++this.cleanupCnt) % 10 != 0) {\n            return;\n        }\n        let newProcessedMessages: any = {};\n        Object.keys(this.processedMessages).forEach(key => {\n            if (this.messageStillActive(key)) return;\n            newProcessedMessages[key] = this.processedMessages[key];\n        });\n        this.processedMessages = newProcessedMessages;\n    }\n\n    private messageStillActive(key: string): boolean {\n        return this.processedMessages[key] > ((new Date()).getMilliseconds() - this.TIMEOUT_IN_MS);\n    }\n\n    protected markMessageAsProcessed(message: Message) {\n        this.processedMessages[message.identifier] = message.creationDate;\n    }\n}\n\nlet broadCastChannelBrokerGenerator = (name) => {\n    if (window?.BroadcastChannel) {\n        return new window.BroadcastChannel(name);\n    }\n    throw Error(\"No Broadcast channel in the system, use a shim or provide a factory function\" +\n        \"in the constructor\");\n};\n\nconst DEFAULT_CHANNEL_GROUP = \"brokr\";\n\n/**\n * a broker which hooks into the Broadcast Channel broker\n * either via shim or substitute lib\n */\nexport class BroadcastChannelBroker extends BaseBroker {\n    private openChannels: [{ key: string }, BroadcastChannel] = <any>{};\n    private readonly msgListener: Function;\n\n\n    /**\n     * @param brokerFactory a factory generating a broker\n     * @param channelGroup a group to combine a set of channels\n     * @param crypto a crypto class\n     */\n    constructor(private brokerFactory: Function = broadCastChannelBrokerGenerator, private channelGroup = DEFAULT_CHANNEL_GROUP, public crypto: Crypto = noEncryption) {\n        super();\n        this.msgListener = (messageData: MessageWrapper) => {\n            if(messageData.detail.encoded) {\n                messageData.detail.message = <any> this.crypto.decode(messageData.detail.message);\n                messageData.detail.encoded = false;\n            }\n            let coreMessage = messageData.detail;\n            let channel: string = messageData.channel;\n\n            if (this.messageListeners?.[channel]) {\n                this.messageListeners?.[channel].forEach(listener => {\n                    listener(coreMessage);\n                })\n            }\n            this.markMessageAsProcessed(coreMessage);\n            return true;\n        }\n        this.crypto = crypto;\n        this.register();\n    }\n\n    broadcast(channel: string, message: Message | string, includeOrigin = true) {\n        try {\n            if('string' == typeof message) {\n                message = new Message(message);\n            }\n            //we now run a quick remapping to avoid\n            //serialisation errors\n            let msgString = JSON.stringify(<Message> message);\n            message = <Message> JSON.parse(msgString);\n\n            let messageWrapper = new MessageWrapper(channel, message);\n            messageWrapper.detail.message = this.crypto.encode(messageWrapper.detail.message);\n            messageWrapper.detail.encoded = true;\n\n            if(this?.subjects[channel]) {\n                this.subjects[channel].next(messageWrapper);\n            }\n\n            this.openChannels[this.channelGroup].postMessage(messageWrapper);\n            if (includeOrigin) {\n                this.msgListener(messageWrapper);\n            }\n        } finally {\n            this.gcProcessedMessages();\n        }\n    }\n\n    registerListener(channel: string, listener: (msg: Message) => void) {\n        super.registerListener(channel, listener);\n    }\n\n    register() {\n        if(!this.openChannels[this.channelGroup]) {\n            this.openChannels[this.channelGroup] = this.brokerFactory(this.channelGroup);\n        }\n        this.openChannels[this.channelGroup].addEventListener(\"message\", this.msgListener);\n    }\n\n    unregister() {\n        this.openChannels[this.channelGroup].close();\n    }\n}\n\n// noinspection JSUnusedGlobalSymbols\n/**\n * Helper factory to create a broadcast channel broker\n */\nexport class BroadcastChannelBrokerFactory {\n   private broadCastChannelGenerator: Function = broadCastChannelBrokerGenerator;\n   private channelGroup = DEFAULT_CHANNEL_GROUP;\n   private crypto = noEncryption;\n\n   withGeneratorFunc(generatorFunc: Function): BroadcastChannelBrokerFactory {\n       this.broadCastChannelGenerator = generatorFunc;\n       return this;\n    }\n\n    withChannelGroup(channelGroup: string): BroadcastChannelBrokerFactory {\n       this.channelGroup = channelGroup;\n       return this;\n    }\n\n    withCrypto(crypto: Crypto): BroadcastChannelBrokerFactory {\n       this.crypto = crypto;\n       return this;\n    }\n\n    build(): BroadcastChannelBroker {\n       return new BroadcastChannelBroker(this.broadCastChannelGenerator, this.channelGroup, this.crypto);\n    }\n\n}\n\n\n/**\n * implementation of a messaging based transport\n */\n\n/**\n * central message broker which uses various dom constructs\n * to broadcast messages into subelements\n *\n * we use the dom event system as transport and iframe and shadow dom mechanisms in a transparent way to\n * pull this off\n *\n * usage\n *\n * broker = new Broker(optional rootElement)\n *\n * defines a message broker within a scope of rootElement (without it is window aka the current isolation level)\n *\n * broker.registerListener(channel, listener) registers a new listener to the current broker and channel\n * broker.unregisterListener(channel, listener) unregisters the given listener\n *\n * broker.broadcast(message, optional direction, optional callBrokerListeners)\n * sends a message (channel included in the message object) in a direction (up, down, both)\n * and also optionally calls the listeners on the same broker (default off)\n *\n * the flow is like\n * up messages are propagated upwards only until it reaches the outer top of the dom\n * downwards, the messages are propagated downwards only\n * both the message is propagated into both directions\n *\n * Usually messages sent from the same broker are not processed within... however by setting\n * callBrokerListeners to true the listeners on the same broker also are called\n * brokers on the same level will get the message and process it automatically no matter what.\n * That way you can exclude the source from message processing (and it is done that way automatically)\n *\n * Isolation levels. Usually every isolation level needs its own broker object registering\n * on the outer bounds\n *\n * aka documents will register on window\n * iframes on the iframe windowObject\n * isolated shadow doms... document\n *\n *\n *\n */\nexport class Broker extends BaseBroker {\n\n    /**\n     * constructor has an optional root element\n     * and an internal name\n     *\n     * @param scopeElement\n     * @param name\n     * @param crypto\n     */\n    constructor(scopeElement: HTMLElement | Window | ShadowRoot = window, public name = \"brokr\", crypto: Crypto = noEncryption) {\n\n        super();\n\n        /**\n         * message relay.. identifies message events and relays them to the listeners\n         * @param event\n         */\n        let evtHandler = (event: MessageEvent | CustomEvent<Message>) => {\n            let details = (<any>event)?.detail ?? (<MessageEvent>event)?.data?.detail;\n            //TODO possible crypto hook, needs unit testing\n            let channel = ((<any>event)?.data?.channel) ?? ((<any>event)?.channel);\n\n            //javascript loses the type info in certain module types\n            if (details?.identifier && details?.message) {\n                let msg: Message = details;\n                if (msg.identifier in this.processedMessages) {\n                    return;\n                }\n                //coming in from up... we need to send it down\n                //a relayed message always has to trigger the listeners as well\n                if((<any>event)?.detail) {\n                    this.broadcast(channel, msg);\n                } else {\n                    this.broadcast(channel, msg);\n                }\n\n            }\n        };\n        this.msgHandler = (evt: MessageEvent) => evtHandler(evt);\n        this.crypto = crypto;\n        this.register(scopeElement);\n    }\n\n    /**\n     * register the current broker into a scope defined by wnd\n     * @param scopeElement\n     */\n    register(scopeElement: HTMLElement | Window | ShadowRoot) {\n        this.rootElem = (<any>scopeElement).host ? (<any>scopeElement).host : scopeElement;\n        if ((<any>scopeElement).host) {\n            let host = (<ShadowRoot>scopeElement).host;\n            host.setAttribute(\"data-broker\", \"1\");\n        } else {\n            if (scopeElement?.[\"setAttribute\"])\n                (<any>scopeElement).setAttribute(\"data-broker\", \"1\");\n        }\n\n        this.rootElem.addEventListener(Broker.EVENT_TYPE, this.msgHandler, {capture: true});\n        /*dom message usable by iframes*/\n        this.rootElem.addEventListener(this.MSG_EVENT, this.msgHandler, {capture: true});\n    }\n\n    /**\n     * manual unregister function, to unregister as broker from the current\n     * scope\n     */\n    unregister() {\n        this.rootElem.removeEventListener(Broker.EVENT_TYPE, this.msgHandler)\n        this.rootElem.removeEventListener(this.MSG_EVENT, this.msgHandler)\n    }\n\n\n    /**\n     * broadcast a message\n     * the message contains the channel and the data and some internal bookkeeping data\n     *\n     * @param channel the channel to broadcast to\n     * @param message the message dot send\n     * (for instance 2 iframes within the same parent broker)\n     */\n    broadcast(channel: string, message: Message | string) {\n        if('string' == typeof message) {\n            message = new Message(message);\n        }\n        //message.message = this.crypto.encode(message);\n        //message.encoded = true;\n\n        if(this?.subjects[channel]) {\n            let messageWrapper = new MessageWrapper(channel, message);\n            if(!messageWrapper.detail.encoded) {\n                messageWrapper.detail.message = this.crypto.encode(messageWrapper.detail.message);\n                messageWrapper.detail.encoded = true;\n            }\n            this.subjects[channel].next(messageWrapper);\n        }\n\n        try {\n            this.dispatchUp(channel, message, false, true);\n            //listeners already called\n            this.dispatchDown(channel, message, true, false)\n        } finally {\n            this.gcProcessedMessages();\n        }\n    }\n\n    private dispatchUp(channel: string, message: Message, ignoreListeners = true, callBrokerListeners = true) {\n        if (!ignoreListeners) {\n            this.msgCallListeners(channel, message);\n        }\n        this.markMessageAsProcessed(message);\n        if (window.parent != null) {\n\n            let messageWrapper = new MessageWrapper(channel, message);\n            window.parent.postMessage(JSON.parse(JSON.stringify(messageWrapper)), message.targetOrigin);\n        }\n        if (callBrokerListeners) {\n            Broker.dispatchSameLevel(channel, message);\n        }\n    }\n\n    private static dispatchSameLevel(channel: string, message: Message) {\n        let event = Broker.transformToEvent(channel, message, true);\n        //we also dispatch sideways\n        window.dispatchEvent(event);\n    }\n\n    //a dispatch of our own should never trigger the listeners hence the default true\n    private dispatchDown(channel: string, message: Message, ignoreListeners = true, callBrokerListeners = true) {\n        if (!ignoreListeners) {\n            this.msgCallListeners(channel, message);\n        }\n        this.processedMessages[message.identifier] = message.creationDate;\n        let evt = Broker.transformToEvent(channel, message);\n\n        /*we now notify all iframes lying underneath */\n        Array.prototype.slice.call(document.querySelectorAll(\"iframe\")).forEach((element: HTMLIFrameElement) => {\n            let messageWrapper = new MessageWrapper(channel, message);\n            element.contentWindow.postMessage(JSON.parse(JSON.stringify(messageWrapper)), message.targetOrigin);\n        });\n\n        Array.prototype.slice.call(document.querySelectorAll(\"[data-broker='1']\")).forEach((element: HTMLElement) => element.dispatchEvent(evt))\n\n        if (callBrokerListeners) {\n            Broker.dispatchSameLevel(channel, message);\n        }\n    }\n\n\n    private msgCallListeners(channel: string, message: Message) {\n        let listeners = this.messageListeners[channel];\n        if (listeners?.length) {\n            let callElement = (element: (msg: Message) => void) => {\n                element(message);\n            }\n\n            listeners.forEach(callElement);\n        }\n    }\n\n    private static transformToEvent(channel: string, message: Message, bubbles = false): CustomEvent {\n        let messageWrapper = new MessageWrapper(channel, message);\n        messageWrapper.bubbles = bubbles;\n        return Broker.createCustomEvent(Broker.EVENT_TYPE, messageWrapper);\n    }\n\n    private static createCustomEvent(name: string, wrapper: MessageWrapper): any {\n        if ('function' != typeof window.CustomEvent) {\n            let e: any = document.createEvent('HTMLEvents');\n            e.detail = wrapper.detail;\n            e.channel = wrapper.channel;\n            e.initEvent(name, wrapper.bubbles, wrapper.cancelable);\n            return e;\n\n        } else {\n            let customEvent = new window.CustomEvent(name, wrapper);\n            (<any>customEvent).channel = wrapper.channel;\n            return customEvent;\n        }\n\n    }\n}\n\n// noinspection JSUnusedGlobalSymbols\n/**\n * Helper factory to create a dom broker\n */\nexport class BrokerFactory {\n    private scopeElement: HTMLElement | Window | ShadowRoot = window;\n    private channelGroup = DEFAULT_CHANNEL_GROUP;\n    private crypto = noEncryption;\n\n    withScopeElement(scopeElement: HTMLElement | Window | ShadowRoot): BrokerFactory {\n        this.scopeElement = scopeElement;\n        return this;\n    }\n\n    withChannelGroup(channelGroup: string): BrokerFactory {\n        this.channelGroup = channelGroup;\n        return this;\n    }\n\n    withCrypto(crypto: Crypto): BrokerFactory {\n        this.crypto = crypto;\n        return this;\n    }\n\n    build(): Broker {\n        return new Broker(this.scopeElement, this.channelGroup, this.crypto);\n    }\n\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__435__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(493);\n"],"names":["decode","data","encode","NoCrypto","noEncryption","message","targetOrigin","encoded","this","creationDate","Date","getMilliseconds","identifier","Math","random","Message","channel","detail","bubbles","cancelable","composed","messageListeners","subjects","processedMessages","cleanupCnt","TIMEOUT_IN_MS","MSG_EVENT","crypto","registerListener","listener","reserveListenerNS","push","msg","asSubject","reserveSubjectNS","subject","oldNext","next","call","broadcast","asObservable","Subject","unregisterListener","filter","item","answer","request","BaseBroker","isAnswer","getAnswerId","indexOf","messageId","ret","Promise","resolve","reject","timeout","message2","clearTimeout","setTimeout","gcProcessedMessages","newProcessedMessages","Object","keys","forEach","key","messageStillActive","markMessageAsProcessed","EVENT_TYPE","broadCastChannelBrokerGenerator","name","window","BroadcastChannel","Error","DEFAULT_CHANNEL_GROUP","brokerFactory","channelGroup","openChannels","msgListener","messageData","coreMessage","register","includeOrigin","msgString","JSON","stringify","parse","messageWrapper","MessageWrapper","postMessage","addEventListener","unregister","close","BroadcastChannelBroker","broadCastChannelGenerator","withGeneratorFunc","generatorFunc","withChannelGroup","withCrypto","build","BroadcastChannelBrokerFactory","scopeElement","msgHandler","evt","event","details","evtHandler","rootElem","host","setAttribute","Broker","capture","removeEventListener","dispatchUp","dispatchDown","ignoreListeners","callBrokerListeners","msgCallListeners","parent","dispatchSameLevel","transformToEvent","dispatchEvent","Array","prototype","slice","document","querySelectorAll","element","contentWindow","listeners","length","createCustomEvent","wrapper","CustomEvent","e","createEvent","initEvent","customEvent","withScopeElement","BrokerFactory","module","exports","__WEBPACK_EXTERNAL_MODULE__435__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}