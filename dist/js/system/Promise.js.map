{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///src/main/typescript/Users/werpu2/development/workspace/monadish/src/main/typescript/Monad.ts","webpack:///src/main/typescript/Users/werpu2/development/workspace/monadish/src/main/typescript/Promise.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Monad","this","_value","fn","inval","result","mapped","map","Stream","data","cnt","length","res","each","item","push","mapStreams","startVal","offset","val1","Optional","fromNullable","absent","matches","concat","super","isAbsent","elseValue","isPresent","flatMap","func","val","getClass","currentPos","currKey","keyVal","arrPos","arrayIndex","Array","getIfPresent","defaultVal","JSON","stringify","start","indexOf","end","parseInt","substring","ConfigEntry","rootElem","Config","root","keys","buildPath","getIf","apply","slice","condition","maps","overwrite","retVal","arrForEach","mixMaps","mergeMaps","parentVal","parentPos","alloc","arr","setVal","tempVal","PromiseStatus","Promise","executor","status","PENDING","allFuncs","resolve","reject","promises","myapply","promiseCnt","myPromise","__last__","finally","myreject","thenexecutor","catchexeutor","then","catch","reason","setTimeout","executorFunc","catchfunc","spliceLastFuncs","__reason__","lastFuncs","rest","shift","funcResult","transferIntoNewPromise","appyFinally","FULLFILLED","REJECTED","CancellablePromise","cancellator"],"mappings":"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","file":"Promise.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/* Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A module which keeps  basic monadish like definitions in place without any sidedependencies to other modules.\n * Useful if you need the functions in another library to keep its dependencies down\n */\n\n/*IMonad definitions*/\n\n\n\n/**\n * IFunctor interface,\n * defines an interface which allows to map a functor\n * via a first order function to another functor\n */\nexport interface IFunctor<T> {\n    map<R>(fn: (data: T) => R): IFunctor<R>;\n}\n\n/**\n * IMonad definition, basically a functor with a flaptmap implementation (flatmap reduces all nested monads after a\n * function call f into a monad with the nesting level of 1\n *\n * flatmap flats nested Monads into a IMonad of the deepest nested implementation\n */\nexport interface IMonad<T, M extends IMonad<any, any>> extends IFunctor<T> {\n    flatMap<T, M>(f: (T) => M): IMonad<any, any>;\n}\n\n/**\n * a stateful functor which holds a value upn which a\n * function can be applied\n *\n * as value holder of type T\n */\nexport interface IIdentity<T> extends IFunctor<T> {\n    readonly value: T;\n}\n\n/**\n *  custom value holder definition, since we are not pure functional\n *  but iterative we have structures which allow the assignment of a value\n *  also not all structures are sideffect free\n */\nexport interface IValueHolder<T> {\n    value: T | Array<T>;\n}\n\n/**\n * Implementation of a monad\n * (Sideffect free), no write allowed directly on the monads\n * value state\n */\nexport class Monad<T> implements IMonad<T, Monad<any>>, IValueHolder<T> {\n    protected _value: T;\n\n    constructor(value: T) {\n        this._value = value;\n    }\n\n    map<R>(fn?: (data: T) => R): Monad<R> {\n        if (!fn) {\n            fn = (inval: any) => <R>inval;\n        }\n        let result: R = fn(this.value);\n        return new Monad(result);\n    }\n\n    flatMap<R>(fn?: (data: T) => R): Monad<any> {\n        let mapped: Monad<any> = this.map(fn);\n        while (\"undefined\" != typeof mapped && mapped != null && mapped.value instanceof Monad) {\n            mapped = mapped.value\n        }\n        return mapped;\n    }\n\n\n    get value(): T {\n        return this._value;\n    }\n\n}\n\n/*\n * A small stream implementation\n */\nexport class Stream<T> implements IMonad<T, Stream<any>>, IValueHolder<Array<T>>{\n\n    static of<T>(... data: Array<T>): Stream<T> {\n        return new Stream<T>(... data);\n    }\n\n    value: Array<T>;\n    constructor(...value: T[]){\n        this.value = value;\n    }\n\n    each(fn: (data: T, pos ?: number) => void | boolean) {\n        for(let cnt = 0; cnt < this.value.length ; cnt++) {\n            if(fn(this.value[cnt], cnt) === false) {\n                break;\n            }\n        }\n        return this;\n    }\n\n    map<R>(fn?: (data: T) => R): Stream<R> {\n        if (!fn) {\n            fn = (inval: any) => <R>inval;\n        }\n        let res: R[] = [];\n        this.each((item, cnt) => {\n            res.push(fn(item))\n        });\n\n        return new Stream<R>(...res);\n    }\n\n    /*\n     * we need to implement it to fullfill the contract, although it is used only internally\n     * all values are flattened when accessed anyway, so there is no need to call this methiod\n     */\n    flatMap<R>(fn?: (data: T) => R): Stream<any> {\n        let mapped:Stream<R> = this.map(fn);\n        let res = this.mapStreams(mapped);\n        return new Stream(...res);\n    }\n\n    filter(fn?: (data: T) => boolean): Stream<T> {\n        let res: Array<T> = [];\n        this.each((data) => {\n            if(fn(data)) {\n                res.push(data);\n            }\n        });\n        return new Stream<T>(...res);\n    }\n\n    reduce(fn: (val1: T, val2:T) => T, startVal: T = null): Optional<T> {\n        let offset = startVal != null ? 0 : 1;\n        let val1 = startVal != null ? startVal : this.value.length ? this.value[0] : null;\n\n        for(let cnt = offset; cnt < this.value.length; cnt++) {\n            val1 = fn(val1, this.value[cnt]);\n        }\n        return Optional.fromNullable(val1);\n    }\n\n    first(): Optional<T> {\n        return this.value && this.value.length ? Optional.fromNullable(this.value[0]) : Optional.absent;\n    }\n\n\n    last(): Optional<T> {\n        //could be done via reduce, but is faster this way\n        return Optional.fromNullable(this.value.length ? this.value[this.value.length -1] : null);\n    }\n\n    anyMatch(fn: (data: T) => boolean): boolean {\n        for(let cnt = 0; cnt < this.value.length; cnt++) {\n            if(fn(this.value[cnt])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    allMatch(fn: (data: T) => boolean): boolean {\n        if(!this.value.length) {\n            return false;\n        }\n        let matches = 0;\n        for(let cnt = 0; cnt < this.value.length; cnt++) {\n            if(fn(this.value[cnt])) {\n                matches++;\n            }\n        }\n        return matches == this.value.length;\n    }\n\n    noneMatch(fn: (data: T) => boolean): boolean {\n        let matches = 0;\n        for(let cnt = 0; cnt < this.value.length; cnt++) {\n            if(fn(this.value[cnt])) {\n                matches++;\n            }\n        }\n        return matches == this.value.length;\n    }\n\n    private mapStreams<R>(mapped: Stream<R>): Array<R> {\n        let res: Array<R> = [];\n        mapped.each((data: any) => {\n            if (data instanceof Stream) {\n                res = res.concat(this.mapStreams(data));\n            } else {\n                res.push(data);\n            }\n        });\n        return res;\n    }\n}\n\n/**\n * optional implementation, an optional is basically an implementation of a Monad with additional syntactic\n * sugar on top\n * (Sideeffect free, since value assignment is not allowed)\n * */\nexport class Optional<T> extends Monad<T> {\n\n\n    constructor(value: T) {\n        super(value);\n    }\n\n    static fromNullable<T>(value?: T): Optional<T> {\n        return new Optional(value);\n    }\n\n    /*default value for absent*/\n    static absent = Optional.fromNullable(null);\n\n    /*syntactic sugar for absent and present checks*/\n    isAbsent(): boolean {\n        return \"undefined\" == typeof this.value || null == this.value;\n    }\n\n    isPresent(): boolean {\n        return !this.isAbsent();\n    }\n\n    orElse(elseValue: any): Optional<any> {\n        if (this.isPresent()) {\n            return this;\n        } else {\n            //shortcut\n            if(elseValue == null) {\n                return Optional.absent;\n            }\n            return this.flatMap(() => elseValue);\n        }\n    }\n\n    /**\n     * lazy, passes a function which then is lazily evaluated\n     * instead of a direct value\n     * @param func\n     */\n    orElseLazy(func: () => any): Optional<any> {\n        if (this.isPresent()) {\n            return this;\n        } else {\n            return this.flatMap(func);\n        }\n    }\n\n    /*\n     * we need to implement it to fullfill the contract, although it is used only internally\n     * all values are flattened when accessed anyway, so there is no need to call this methiod\n     */\n    flatMap<R>(fn?: (data: T) => R): Optional<any> {\n        let val = super.flatMap(fn);\n        if (!(val instanceof Optional)) {\n            return Optional.fromNullable(val.value);\n        }\n\n        return <Optional<any>> val.flatMap();\n    }\n\n    /**\n     * additional syntactic sugar which is not part of the usual optional implementation\n     * but makes life easier, if you want to sacrifice typesafety and refactoring\n     * capabilities in typescript\n     */\n    private getIfPresent<R>(key: string): Optional<R> {\n        if (this.isAbsent()) {\n            return this.getClass().absent;\n        }\n        return this.getClass().fromNullable(this.value[key]).flatMap();\n    }\n\n\n    /*\n     * elvis operation, take care, if you use this you lose typesafety and refactoring\n     * capabilites, unfortunately typesceript does not allow to have its own elvis operator\n     * this is some syntactic sugar however which is quite useful*/\n    getIf<R>(...key: string[]): Optional<R> {\n\n        let currentPos: Optional<any> = this;\n        for (let cnt = 0; cnt < key.length; cnt++) {\n            let currKey = this.keyVal(key[cnt]);\n            let arrPos = this.arrayIndex(key[cnt]);\n\n            if (currKey === \"\" && arrPos >= 0) {\n                currentPos = this.getClass().fromNullable(!(currentPos.value instanceof Array ) ? null : (currentPos.value.length < arrPos ? null : currentPos.value[arrPos]));\n                if (currentPos.isAbsent()) {\n                    return currentPos;\n                }\n                continue;\n            } else if (currKey && arrPos >= 0) {\n                if (currentPos.getIfPresent(currKey).isAbsent()) {\n                    return currentPos;\n                }\n                currentPos = (currentPos.getIfPresent(currKey).value instanceof Array) ? this.getClass().fromNullable(currentPos.getIfPresent(currKey).value[arrPos]) : this.getClass().absent;\n                if (currentPos.isAbsent()) {\n                    return currentPos;\n                }\n                continue;\n\n            } else {\n                currentPos = currentPos.getIfPresent(currKey);\n            }\n            if (currentPos.isAbsent()) {\n                return currentPos;\n            } else if (arrPos > -1) {\n                currentPos = this.getClass().fromNullable(currentPos.value[arrPos]);\n            }\n        }\n        let retVal = currentPos;\n\n        return retVal;\n    }\n\n    get value(): T {\n        if (this._value instanceof Monad) {\n            return this._value.flatMap().value\n        }\n        return this._value;\n    }\n\n    /**\n     * simple match, if the first order function call returns\n     * true then there is a match, if the value is not present\n     * it never matches\n     *\n     * @param fn the first order function performing the match\n     */\n    match(fn: (item: T) => boolean): boolean {\n        if(this.isAbsent()) {\n            return false\n        }\n        return fn(this.value);\n    }\n\n    /**\n     * convenience function to flatmap the internal value\n     * and replace it with a default in case of being absent\n     *\n     * @param defaultVal\n     * @returns {Optional<any>}\n     */\n    get<R>(defaultVal: any = Optional.absent): Optional<R> {\n        if (this.isAbsent()) {\n            return this.getClass().fromNullable(defaultVal).flatMap();\n        }\n\n        return this.getClass().fromNullable(this.value).flatMap();\n    }\n\n    /**\n     * helper to override several implementations in a more fluent way\n     * by having a getClass operation we can avoid direct calls into the constructor or\n     * static methods and do not have to implement several methods which rely on the type\n     * of \"this\"\n     * @returns {Monadish.Optional}\n     */\n    protected getClass(): any {\n        return Optional;\n    }\n\n    toJson(): string {\n        return JSON.stringify(this.value);\n    }\n\n    /*helper method for getIf with array access aka <name>[<indexPos>]*/\n    protected arrayIndex(key: string): number {\n        let start = key.indexOf(\"[\");\n        let end = key.indexOf(\"]\");\n        if (start >= 0 && end > 0 && start < end) {\n            return parseInt(key.substring(start + 1, end));\n        } else {\n            return -1;\n        }\n    }\n\n    /*helper method for getIf with array access aka <name>[<indexPos>]*/\n    protected keyVal(key: string): string {\n        let start = key.indexOf(\"[\");\n\n        if (start >= 0) {\n            return key.substring(0, start);\n        } else {\n            return key;\n        }\n    }\n\n\n}\n\n\n/**\n * helper class to allow write access to the config\n * in certain situations (after an apply call)\n */\nclass ConfigEntry<T> implements IValueHolder<T> {\n    rootElem: any;\n    key: any;\n    arrPos: number;\n\n\n    constructor(rootElem: any, key: any, arrPos?: number) {\n        this.rootElem = rootElem;\n        this.key = key;\n        this.arrPos = (\"undefined\" != typeof arrPos) ? arrPos : -1;\n    }\n\n    get value() {\n        if (this.key == \"\" && this.arrPos >= 0) {\n            return this.rootElem[this.arrPos];\n        } else if (this.key && this.arrPos >= 0) {\n            return this.rootElem[this.key][this.arrPos];\n        }\n        return this.rootElem[this.key];\n    }\n\n    set value(val: T) {\n        if (this.key == \"\" && this.arrPos >= 0) {\n            this.rootElem[this.arrPos] = val;\n            return;\n        } else if (this.key && this.arrPos >= 0) {\n            this.rootElem[this.key][this.arrPos] = val;\n            return;\n        }\n        this.rootElem[this.key] = val;\n    }\n}\n\n/**\n * Config, basically an optional wrapper for a json structure\n * (not sideeffect free, since we can alter the internal config state\n * without generating a new config), not sure if we should make it sideffect free\n * since this would swallow a lot of performane and ram\n */\nexport class Config extends Optional<any> {\n    constructor(root: any) {\n        super(root);\n    }\n\n    static fromNullable<T>(value?: any): Config {\n        return new Config(value);\n    }\n\n    apply(...keys: Array<any>): IValueHolder<any> {\n        if (keys.length < 1) {\n            return;\n        }\n\n        this.buildPath(keys);\n\n        let currKey = this.keyVal(keys[keys.length - 1]);\n        let arrPos = this.arrayIndex(keys[keys.length - 1]);\n        let retVal = new ConfigEntry(keys.length == 1 ? this.value : this.getIf.apply(this, keys.slice(0, keys.length - 1)).value,\n            currKey, arrPos\n        );\n\n        return retVal;\n    }\n\n\n    applyIf(condition: boolean,...keys: Array<any>): IValueHolder<any> {\n        return  condition ? this.apply(keys) : {value: null};\n    }\n\n\n\n    getIf(...keys: Array<string>): Config {\n        return this.getClass().fromNullable(super.getIf.apply(this, keys).value);\n    }\n\n    get(defaultVal: any): Config {\n        return this.getClass().fromNullable(super.get(defaultVal).value);\n    }\n\n    //empties the current config entry\n    delete(key: string): Config {\n        if(key in this.value) {\n            delete this.value[key];\n        }\n        return this;\n    }\n\n    toJson(): any {\n        return JSON.stringify(this.value);\n    }\n\n    get shallowCopy(): Config {\n        let mergeMaps = function(maps: any[], overwrite = true) {\n            let retVal = {};\n            this.arrForEach(maps, (item:{[key:string]:any})  => {\n                this.mixMaps(retVal, item, overwrite)\n            });\n            return retVal;\n        }\n        return new Config(mergeMaps([{}, this.value || {}]));\n    }\n\n    protected getClass(): any {\n        return Config;\n    }\n\n    private setVal(val: any) {\n        this._value = val;\n    }\n\n    private buildPath(keys: Array<any>): Config {\n        let val = this;\n        let parentVal = this.getClass().fromNullable(null);\n        let parentPos = -1;\n        let alloc = function (arr: Array<any>, length: number) {\n            if (arr.length < length) {\n                for (let cnt = arr.length; cnt < length; cnt++) {\n                    arr.push({});\n                }\n            }\n        };\n\n\n        for (let cnt = 0; cnt < keys.length; cnt++) {\n            let currKey = this.keyVal(keys[cnt]);\n            let arrPos = this.arrayIndex(keys[cnt]);\n\n            if (currKey === \"\" && arrPos >= 0) {\n\n                val.setVal((val.value instanceof Array) ? val.value : []);\n                alloc(val.value, arrPos + 1);\n                if (parentPos >= 0) {\n                    parentVal.value[parentPos] = val.value;\n                }\n                parentVal = val;\n                parentPos = arrPos;\n                val = this.getClass().fromNullable(val.value[arrPos]);\n                continue;\n            }\n\n            let tempVal = <Config> val.getIf(currKey);\n            if (arrPos == -1) {\n                if (tempVal.isAbsent()) {\n                    tempVal = <Config> this.getClass().fromNullable(val.value[currKey] = {});\n                } else {\n                    val = <any>tempVal;\n                }\n            } else {\n                let arr = (tempVal.value instanceof Array) ? tempVal.value : [];\n                alloc(arr, arrPos + 1);\n                val.value[currKey] = arr;\n                tempVal = this.getClass().fromNullable(arr[arrPos]);\n            }\n            parentVal = val;\n            parentPos = arrPos;\n            val = <any>tempVal;\n        }\n\n        return this;\n    }\n}\n\n\n\n/*we do not implenent array, maps etc.. monads there are libraries like lodash which have been doing that for ages*/\n\n","import {Optional} from \"./Monad\";\n\n\nexport enum PromiseStatus {\n    PENDING, FULLFILLED, REJECTED\n}\n\nexport interface IPromise {\n    then(executorFunc: (val: any) => any): IPromise;\n\n    catch(executorFunc: (val: any) => any): IPromise\n\n    finally(executorFunc: () => void): IPromise;\n\n}\n\n\n\n/**\n * a small (probably not 100% correct, although I tried to be correct as possible) Promise implementation\n * for systems which do not have a promise implemented\n * Note, although an internal state is kept, this is sideffect free since\n * is value is a function to operate on, hence no real state is kept internally, except for the then\n * and catch calling order\n */\nexport class Promise implements IPromise {\n\n    private value: (resolve: (val?: any) => void, reject: (val?: any) => void) => void;\n\n    status = PromiseStatus.PENDING;\n\n    protected allFuncs: Array<any> = [];\n\n    constructor(executor: (resolve: (val?: any) => void, reject: (val?: any) => void) => void) {\n        //super(executor);\n        this.value = executor;\n        this.value((data: any) => this.resolve(data), (data: any) => this.reject(data));\n    }\n\n    static all(...promises: Array<IPromise>): IPromise {\n\n        let promiseCnt = 0;\n        let myapply: Function;\n\n        let myPromise = new Promise((apply: Function, reject: Function) => {\n            myapply = apply;\n        });\n        let executor = () => {\n            promiseCnt++;\n\n            if (promises.length == promiseCnt) {\n                myapply();\n            }\n        };\n        (<any>executor).__last__ = true;\n\n        for (let cnt = 0; cnt < promises.length; cnt++) {\n            promises[cnt].finally(executor);\n        }\n        return myPromise;\n    }\n\n\n    static race(...promises: Array<IPromise>): IPromise {\n\n        let promiseCnt = 0;\n        let myapply: Function;\n        let myreject: Function;\n\n        let myPromise = new Promise((apply: Function, reject: Function) => {\n            myapply = apply;\n            myreject = reject;\n        });\n\n\n        let thenexecutor = (): IPromise => {\n            if (!!myapply) {\n                myapply();\n            }\n            myapply = null;\n            myreject = null;\n            return null;\n        };\n        (<any>thenexecutor).__last__ = true;\n\n        let catchexeutor = (): IPromise => {\n            if (!!myreject) {\n                myreject();\n            }\n            myreject = null;\n            myapply = null;\n            return null;\n        };\n        (<any>catchexeutor).__last__ = true;\n\n        for (let cnt = 0; cnt < promises.length; cnt++) {\n            promises[cnt].then(thenexecutor);\n            promises[cnt].catch(catchexeutor);\n        }\n        return myPromise;\n    }\n\n    static reject(reason: any): Promise {\n        let retVal = new Promise((resolve: any, reject: any) => {\n            //not really doable without a hack\n            if (reason instanceof Promise) {\n                reason.then((val: any) => {\n                    reject(val);\n                });\n            } else {\n                setTimeout(() => {\n                    reject(reason);\n                }, 1);\n            }\n        });\n\n        return retVal;\n    }\n\n    static resolve(reason: any): Promise {\n        let retVal = new Promise((resolve: any, reject: any) => {\n            //not really doable without a hack\n            if (reason instanceof Promise) {\n                reason.then((val) => resolve(val));\n            } else {\n                setTimeout(() => {\n                    resolve(reason);\n                }, 1);\n            }\n        });\n\n        return retVal;\n\n    }\n\n    then(executorFunc: (val?: any) => any, catchfunc?: (val?: any) => any): Promise {\n        this.allFuncs.push({\"then\": executorFunc});\n        if (catchfunc) {\n            this.allFuncs.push({\"catch\": catchfunc});\n        }\n        this.spliceLastFuncs();\n        return this;\n    }\n\n    catch(executorFunc: (val?: any) => void): Promise {\n        this.allFuncs.push({\"catch\": executorFunc});\n        this.spliceLastFuncs();\n        return this;\n    }\n\n\n    finally(executorFunc: () => void): Promise {\n        if ((<any>this).__reason__) {\n            (<any>this).__reason__.finally(executorFunc);\n            return;\n        }\n\n        this.allFuncs.push({\"finally\": executorFunc});\n        this.spliceLastFuncs();\n        return this;\n    }\n\n    private spliceLastFuncs() {\n        let lastFuncs = [];\n        let rest = [];\n        for (let cnt = 0; cnt < this.allFuncs.length; cnt++) {\n            for (let key in this.allFuncs[cnt]) {\n                if (this.allFuncs[cnt][key].__last__) {\n                    lastFuncs.push(this.allFuncs[cnt]);\n                } else {\n                    rest.push(this.allFuncs[cnt]);\n                }\n            }\n        }\n        this.allFuncs = rest.concat(lastFuncs);\n    }\n\n\n    protected resolve(val?: any) {\n\n\n        while (this.allFuncs.length) {\n            if (!this.allFuncs[0].then) {\n                break;\n            }\n            let fn = this.allFuncs.shift();\n\n            let funcResult = Optional.fromNullable(fn.then(val));\n\n            if (funcResult.isPresent()) {\n                funcResult = funcResult.flatMap();\n                val = funcResult.value;\n                if (val instanceof Promise) {\n                    //var func = (newVal: any) => {this.resolve(newVal)};\n                    //func.__last__  = true;\n                    //val.then(func);\n                    this.transferIntoNewPromise(val);\n\n                    return;\n                }\n            } else {\n                break;\n            }\n        }\n\n        this.appyFinally();\n        this.status = PromiseStatus.FULLFILLED;\n    }\n\n    protected reject(val?: any) {\n\n        while (this.allFuncs.length) {\n            if (this.allFuncs[0].finally) {\n                break;\n            }\n            var fn = this.allFuncs.shift();\n            if (fn.catch) {\n                var funcResult = Optional.fromNullable(fn.catch(val));\n                if (funcResult.isPresent()) {\n                    funcResult = funcResult.flatMap();\n                    val = funcResult.value;\n                    if (val instanceof Promise) {\n                        //val.then((newVal: any) => {this.resolve(newVal)});\n                        this.transferIntoNewPromise(val);\n                        return;\n                    }\n                    this.status = PromiseStatus.REJECTED;\n                    break;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        this.status = PromiseStatus.REJECTED;\n        this.appyFinally();\n    }\n\n    private transferIntoNewPromise(val: any) {\n        for (var cnt = 0; cnt < this.allFuncs.length; cnt++) {\n            for (let key in this.allFuncs[cnt]) {\n                val[key](this.allFuncs[cnt][key]);\n            }\n        }\n    }\n\n    protected appyFinally() {\n        while (this.allFuncs.length) {\n            var fn = this.allFuncs.shift();\n            if (fn.finally) {\n                fn.finally();\n            }\n        }\n    }\n}\n\n/**\n * a cancellable promise\n * a Promise with a cancel function, which can be cancellend any time\n * this is useful for promises which use cancellable asynchronous operations\n * note, even in a cancel state, the finally of the promise is executed, however\n * subsequent thens are not anymore.\n * The current then however is fished or a catch is called depending on how the outer\n * operation reacts to a cancel order.\n */\nexport class CancellablePromise extends Promise {\n\n    private cancellator = () => {\n    };\n\n    /**\n     * @param executor asynchronous callback operation which triggers the callback\n     * @param cancellator cancel operation, separate from the trigger operation\n     */\n    constructor(executor: (resolve: (val?: any) => void, reject: (val?: any) => void) => void, cancellator: () => void) {\n        super(executor);\n        this.cancellator = cancellator;\n    }\n\n    cancel() {\n        this.status = PromiseStatus.REJECTED;\n        this.appyFinally();\n        //lets terminate it once and for all, the finally has been applied\n        this.allFuncs = [];\n    }\n\n\n    then(executorFunc: (val?: any) => any, catchfunc?: (val?: any) => any): CancellablePromise {\n        return <CancellablePromise> super.then(executorFunc, catchfunc);\n    }\n\n    catch(executorFunc: (val?: any) => void): CancellablePromise {\n        return <CancellablePromise> super.catch(executorFunc);\n    }\n\n    finally(executorFunc: () => void): CancellablePromise {\n        return <CancellablePromise> super.finally(executorFunc);\n    }\n}\n\n\n\n"],"sourceRoot":""}