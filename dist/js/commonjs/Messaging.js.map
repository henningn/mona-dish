{"version":3,"sources":["webpack:///webpack/startup","webpack:///./src/main/typescript/Users/werpu2/development/workspace/monadish/src/main/typescript/Messaging.ts"],"names":["__webpack_exports__","message","targetOrigin","this","creationDate","Date","getMilliseconds","identifier","Math","random","Message","channel","detail","bubbles","cancelable","composed","messageListeners","processedMessages","cleanupCnt","TIMEOUT_IN_MS","MSG_EVENT","registerListener","listener","reserveListenerNS","push","msg","unregisterListener","filter","item","answer","request","BaseBroker","isAnswer","getAnswerId","broadcast","indexOf","messageId","ret","Promise","resolve","reject","timeout","message2","clearTimeout","setTimeout","gcProcessedMessages","newProcessedMessages","Object","keys","forEach","key","messageStillActive","markMessageAsProcessed","EVENT_TYPE","brokerFactory","channelGroup","name","window","BroadcastChannel","Error","openChannels","msgListener","messageData","coreMessage","register","includeOrigin","msgString","JSON","stringify","parse","messageWrapper","MessageWrapper","postMessage","addEventListener","unregister","close","BroadcastChannelBroker","scopeElement","msgHandler","evt","event","details","data","evtHandler","rootElem","host","setAttribute","Broker","capture","removeEventListener","dispatchUp","dispatchDown","ignoreListeners","callBrokerListeners","msgCallListeners","parent","dispatchSameLevel","transformToEvent","dispatchEvent","Array","prototype","slice","call","document","querySelectorAll","element","contentWindow","listeners","length","createCustomEvent","wrapper","CustomEvent","e","createEvent","initEvent","customEvent"],"mappings":"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","file":"Messaging.js","sourcesContent":["// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[493](0, __webpack_exports__);\n","/**\n * a standardized message to be sent over the message bus\n */\n\nexport class Message {\n\n    creationDate?: number;\n    identifier?: string;\n    targetOrigin?: string;\n\n    constructor(public message: any = {}, targetOrigin = \"*\") {\n        this.targetOrigin = targetOrigin;\n        this.creationDate = new Date().getMilliseconds();\n        this.identifier = new Date().getMilliseconds() + \"_\" + Math.random() + \"_\" + Math.random();\n    }\n}\n\n/**\n * custom dom event wrapping our messages\n */\nclass MessageWrapper implements CustomEventInit<Message> {\n\n    detail?: Message;\n    bubbles?: boolean;\n    cancelable?: boolean;\n    composed?: boolean;\n    channel: string;\n\n\n    constructor(channel: string, message: Message) {\n        this.detail = message;\n        this.bubbles = true;\n        this.cancelable = true;\n        this.composed = true;\n        this.channel = channel;\n    }\n}\n\n\nabstract class BaseBroker {\n\n    static readonly EVENT_TYPE = \"brokerEvent\";\n    /**\n     * we can split the listeners with the system\n     * namespace... and type (aka identifier criteria)\n     */\n    protected messageListeners: any = {};\n    protected processedMessages: any = {};\n    protected cleanupCnt = 0;\n    protected rootElem;\n    protected msgHandler;\n\n    protected readonly TIMEOUT_IN_MS = 1000;\n    protected readonly MSG_EVENT = \"message\";\n\n\n    abstract register(scopeElement?: any);\n\n    abstract unregister();\n\n    abstract broadcast(channel: string, message: Message | string);\n\n\n    /**\n     * registers a listener on a channel\n     * @param channel the channel to register the listeners for\n     * @param listener the listener to register\n     */\n    registerListener(channel: string, listener: (msg: Message) => void) {\n        this.reserveListenerNS(channel);\n\n        //we skip the processed messages, because they originated here\n        //and already are processed\n        this.messageListeners[channel].push((msg: Message) => {\n            if (msg.identifier in this.processedMessages) {\n                return;\n            }\n            listener(msg);\n        });\n    }\n\n    /**\n     * reserves the listener namespace and wildcard namespace for the given identifier\n     * @param identifier\n     * @private\n     */\n    private reserveListenerNS(identifier: string) {\n        if (!this.messageListeners[identifier]) {\n            this.messageListeners[identifier] = [];\n        }\n        if (!this.messageListeners[\"*\"]) {\n            this.messageListeners[\"*\"] = [];\n        }\n    }\n\n    /**\n     * unregisters a listener from this channel\n     *\n     * @param channel the channel to unregister from\n     * @param listener the listener to unregister the channel from\n     */\n    unregisterListener(channel: string, listener: (msg: Message) => void) {\n        this.messageListeners[channel] = (this.messageListeners[channel] || []).filter((item: any) => item !== listener);\n    }\n\n    /**\n     * answers a bidirectional message received\n     * usage, the client can use this method, to answer an incoming message in a precise manner\n     * so that the caller sending the bidirectional message knows how to deal with it\n     * this mechanism can be used for global storages where we have one answering entity per channel delivering the\n     * requested data, the request can be done asynchronously via promises waiting for answers\n     *\n     * @param channel the channel the originating message\n     * @param request the requesting message\n     * @param answer the answer to the request\n     */\n    answer(channel: string, request: Message |string, answer: Message) {\n        if('string' == typeof request) {\n            request = new Message(request);\n        }\n\n        if (BaseBroker.isAnswer(request)) {\n            return;\n        }\n        answer.identifier = BaseBroker.getAnswerId(request);\n        this.broadcast(channel, answer);\n    }\n\n    private static getAnswerId(request: Message) {\n        return \"_r_\" + request.identifier;\n    }\n\n    private static isAnswer(request: Message) {\n        return request.identifier.indexOf(\"_r_\") == 0;\n    }\n\n    /**\n     * idea... a bidirectional broadcast\n     * sends a message and waits for the first answer coming in from one of the receivers\n     * sending the message back with a messageIdentifier_broadCastId answer\n     *\n     * @param channel\n     * @param message\n     */\n    request(channel: string, message: Message | string): Promise<Message> {\n        if('string' == typeof message) {\n            message = new Message(message);\n        }\n        let messageId = message.identifier;\n\n        let ret = new Promise<Message>((resolve, reject) => {\n            let timeout = null;\n            let listener = (message2: Message) => {\n                if (message2.identifier == messageId) {\n                    //broadcast from same source, we do not want\n                    //to deal with it now\n                    return;\n                }\n\n                if (message2.identifier == \"_r_\" + messageId) {\n                    clearTimeout(timeout);\n                    this.unregisterListener(channel, listener);\n                    resolve(message2);\n                }\n            }\n            timeout = setTimeout(() => {\n                this.unregisterListener(channel, listener);\n                reject(\"request message performed, timeout, no return value\");\n            }, 3000);\n            this.registerListener(channel, listener);\n\n        });\n        this.broadcast(channel, message);\n        return ret;\n    }\n\n\n    /**\n     * garbage collects the processed messages queue\n     * usually after one second\n     */\n    protected gcProcessedMessages() {\n        if ((++this.cleanupCnt) % 10 != 0) {\n            return;\n        }\n        let newProcessedMessages: any = {};\n        Object.keys(this.processedMessages).forEach(key => {\n            if (this.messageStillActive(key)) return;\n            newProcessedMessages[key] = this.processedMessages[key];\n        });\n        this.processedMessages = newProcessedMessages;\n    }\n\n    private messageStillActive(key: string): boolean {\n        return this.processedMessages[key] > ((new Date()).getMilliseconds() - this.TIMEOUT_IN_MS);\n    }\n\n    protected markMessageAsProcessed(message: Message) {\n        this.processedMessages[message.identifier] = message.creationDate;\n    }\n}\n\n/**\n * a broker which hooks into the Broadcast Channel broker\n * either via shim or substitute lib\n */\nexport class BroadcastChannelBroker extends BaseBroker {\n    private openChannels: [{ key: string }, BroadcastChannel] = <any>{};\n    private readonly msgListener: Function;\n\n    /**\n     * @param brokerFactory a factory generating a broker\n     * @param channelGroup a group to combine a set of channels\n     */\n    constructor(private brokerFactory: Function = (name) => {\n        if (window?.BroadcastChannel) {\n            return new window.BroadcastChannel(name);\n        }\n        throw Error(\"No Broadcast channel in the system, use a shim or provide a factory function\" +\n            \"in the constructor\");\n    }, private channelGroup = \"brokr\") {\n        super();\n        this.msgListener = (messageData: MessageWrapper) => {\n            let coreMessage = messageData.detail;\n            let channel: string = messageData.channel;\n\n            if (this.messageListeners?.[channel]) {\n                this.messageListeners?.[channel].forEach(listener => {\n                    listener(coreMessage);\n                })\n            }\n            this.markMessageAsProcessed(coreMessage);\n            return true;\n        }\n        this.register();\n    }\n\n    broadcast(channel: string, message: Message | string, includeOrigin = true) {\n        try {\n            if('string' == typeof message) {\n                message = new Message(message);\n            }\n            //we now run a quick remapping to avoid\n            //serialisation errors\n            let msgString = JSON.stringify(<Message> message);\n            message = <Message> JSON.parse(msgString);\n\n            let messageWrapper = new MessageWrapper(channel, message);\n            this.openChannels[this.channelGroup].postMessage(messageWrapper);\n            if (includeOrigin) {\n                this.msgListener(messageWrapper);\n            }\n        } finally {\n            this.gcProcessedMessages();\n        }\n    }\n\n\n\n    registerListener(channel: string, listener: (msg: Message) => void) {\n        super.registerListener(channel, listener);\n    }\n\n    register() {\n        if(!this.openChannels[this.channelGroup]) {\n            this.openChannels[this.channelGroup] = this.brokerFactory(this.channelGroup);\n        }\n        this.openChannels[this.channelGroup].addEventListener(\"message\", this.msgListener);\n    }\n\n    unregister() {\n        this.openChannels[this.channelGroup].close();\n    }\n}\n\n\n/**\n * implementation of a messaging based transport\n */\n\n/**\n * central message broker which uses various dom constructs\n * to broadcast messages into subelements\n *\n * we use the dom event system as transport and iframe and shadow dom mechanisms in a transparent way to\n * pull this off\n *\n * usage\n *\n * broker = new Broker(optional rootElement)\n *\n * defines a message broker within a scope of rootElement (without it is window aka the current isolation level)\n *\n * broker.registerListener(channel, listener) registers a new listener to the current broker and channel\n * broker.unregisterListener(channel, listener) unregisters the given listener\n *\n * broker.broadcast(message, optional direction, optional callBrokerListeners)\n * sends a message (channel included in the message object) in a direction (up, down, both)\n * and also optionally calls the listeners on the same broker (default off)\n *\n * the flow is like\n * up messages are propagated upwards only until it reaches the outer top of the dom\n * downwards, the messages are propagated downwards only\n * both the message is propagated into both directions\n *\n * Usually messages sent from the same broker are not processed within... however by setting\n * callBrokerListeners to true the listeners on the same broker also are called\n * brokers on the same level will get the message and process it automatically no matter what.\n * That way you can exclude the source from message processing (and it is done that way automatically)\n *\n * Isolation levels. Usually every isolation level needs its own broker object registering\n * on the outer bounds\n *\n * aka documents will register on window\n * iframes on the iframe windowObject\n * isolated shadow doms... document\n *\n *\n *\n */\nexport class Broker extends BaseBroker {\n\n    /**\n     * constructor has an optional root element\n     * and an internal name\n     *\n     * @param scopeElement\n     * @param name\n     */\n    constructor(scopeElement: HTMLElement | Window | ShadowRoot = window, public name = \"brokr\") {\n\n        super();\n\n        /**\n         * message relay.. identifies message events and relays them to the listeners\n         * @param event\n         */\n        let evtHandler = (event: MessageEvent | CustomEvent<Message>) => {\n            let details = (<any>event)?.detail ?? (<MessageEvent>event)?.data?.detail;\n            let channel = ((<any>event)?.data?.channel) ?? ((<any>event)?.channel);\n\n            //javascript loses the type info in certain module types\n            if (details?.identifier && details?.message) {\n                let msg: Message = details;\n                if (msg.identifier in this.processedMessages) {\n                    return;\n                }\n                //coming in from up... we need to send it down\n                //a relayed message always has to trigger the listeners as well\n                this.broadcast(channel, msg);\n            }\n        };\n        this.msgHandler = (evt: MessageEvent) => evtHandler(evt);\n        this.register(scopeElement);\n    }\n\n    /**\n     * register the current broker into a scope defined by wnd\n     * @param scopeElement\n     */\n    register(scopeElement: HTMLElement | Window | ShadowRoot) {\n        this.rootElem = (<any>scopeElement).host ? (<any>scopeElement).host : scopeElement;\n        if ((<any>scopeElement).host) {\n            let host = (<ShadowRoot>scopeElement).host;\n            host.setAttribute(\"data-broker\", \"1\");\n        } else {\n            if (scopeElement?.[\"setAttribute\"])\n                (<any>scopeElement).setAttribute(\"data-broker\", \"1\");\n        }\n\n        this.rootElem.addEventListener(Broker.EVENT_TYPE, this.msgHandler, {capture: true});\n        /*dom message usable by iframes*/\n        this.rootElem.addEventListener(this.MSG_EVENT, this.msgHandler, {capture: true});\n    }\n\n    /**\n     * manual unregister function, to unregister as broker from the current\n     * scope\n     */\n    unregister() {\n        this.rootElem.removeEventListener(Broker.EVENT_TYPE, this.msgHandler)\n        this.rootElem.removeEventListener(this.MSG_EVENT, this.msgHandler)\n    }\n\n\n    /**\n     * broadcast a message\n     * the message contains the channel and the data and some internal bookkeeping data\n     *\n     * @param channel the channel to broadcast to\n     * @param message the message dot send\n     * (for instance 2 iframes within the same parent broker)\n     *\n     */\n    broadcast(channel: string, message: Message | string) {\n        if('string' == typeof message) {\n            message = new Message(message);\n        }\n        try {\n            this.dispatchUp(channel, message, false, true);\n            //listeners already called\n            this.dispatchDown(channel, message, true, false)\n        } finally {\n            this.gcProcessedMessages();\n        }\n    }\n\n    private dispatchUp(channel: string, message: Message, ignoreListeners = true, callBrokerListeners = true) {\n        if (!ignoreListeners) {\n            this.msgCallListeners(channel, message);\n        }\n        this.markMessageAsProcessed(message);\n        if (window.parent != null) {\n\n            let messageWrapper = new MessageWrapper(channel, message);\n            window.parent.postMessage(JSON.parse(JSON.stringify(messageWrapper)), message.targetOrigin);\n        }\n        if (callBrokerListeners) {\n            Broker.dispatchSameLevel(channel, message);\n        }\n    }\n\n    private static dispatchSameLevel(channel: string, message: Message) {\n        let event = Broker.transformToEvent(channel, message, true);\n        //we also dispatch sideways\n        window.dispatchEvent(event);\n    }\n\n    //a dispatch of our own should never trigger the listeners hence the default true\n    private dispatchDown(channel: string, message: Message, ignoreListeners = true, callBrokerListeners = true) {\n        if (!ignoreListeners) {\n            this.msgCallListeners(channel, message);\n        }\n        this.processedMessages[message.identifier] = message.creationDate;\n        let evt = Broker.transformToEvent(channel, message);\n\n        /*we now notify all iframes lying underneath */\n        Array.prototype.slice.call(document.querySelectorAll(\"iframe\")).forEach((element: HTMLIFrameElement) => {\n            let messageWrapper = new MessageWrapper(channel, message);\n            element.contentWindow.postMessage(JSON.parse(JSON.stringify(messageWrapper)), message.targetOrigin);\n        });\n\n        Array.prototype.slice.call(document.querySelectorAll(\"[data-broker='1']\")).forEach((element: HTMLElement) => element.dispatchEvent(evt))\n\n        if (callBrokerListeners) {\n            Broker.dispatchSameLevel(channel, message);\n        }\n    }\n\n\n    private msgCallListeners(channel: string, message: Message) {\n        let listeners = this.messageListeners[channel];\n        if (listeners?.length) {\n            let callElement = (element: (msg: Message) => void) => {\n                element(message);\n            }\n\n            listeners.forEach(callElement);\n        }\n    }\n\n    private static transformToEvent(channel: string, message: Message, bubbles = false): CustomEvent {\n        let messageWrapper = new MessageWrapper(channel, message);\n        messageWrapper.bubbles = bubbles;\n        return Broker.createCustomEvent(Broker.EVENT_TYPE, messageWrapper);\n    }\n\n    private static createCustomEvent(name: string, wrapper: MessageWrapper): any {\n        if ('function' != typeof window.CustomEvent) {\n            let e: any = document.createEvent('HTMLEvents');\n            e.detail = wrapper.detail;\n            e.channel = wrapper.channel;\n            e.initEvent(name, wrapper.bubbles, wrapper.cancelable);\n            return e;\n\n        } else {\n            let customEvent = new window.CustomEvent(name, wrapper);\n            (<any>customEvent).channel = wrapper.channel;\n            return customEvent;\n        }\n\n    }\n}"],"sourceRoot":""}