{"version":3,"file":"Messaging.js","mappings":"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","sources":["webpack:///./src/main/typescript/Users/werpu2/development/workspace/monadish/src/main/typescript/Messaging.ts","webpack:///external \"rxjs\"","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"sourcesContent":["/**\n * a standardized message to be sent over the message bus\n */\nimport {Observable, Subject} from \"rxjs\";\n\nexport class Message {\n\n    creationDate?: number;\n    identifier?: string;\n    targetOrigin?: string;\n\n    constructor(public message: any = {}, targetOrigin = \"*\") {\n        this.targetOrigin = targetOrigin;\n        this.creationDate = new Date().getMilliseconds();\n        this.identifier = new Date().getMilliseconds() + \"_\" + Math.random() + \"_\" + Math.random();\n    }\n}\n\n/**\n * custom dom event wrapping our messages\n */\nclass MessageWrapper implements CustomEventInit<Message> {\n\n    detail?: Message;\n    bubbles?: boolean;\n    cancelable?: boolean;\n    composed?: boolean;\n    channel: string;\n\n\n    constructor(channel: string, message: Message) {\n        this.detail = message;\n        this.bubbles = true;\n        this.cancelable = true;\n        this.composed = true;\n        this.channel = channel;\n    }\n}\n\n\nabstract class BaseBroker {\n\n    static readonly EVENT_TYPE = \"brokerEvent\";\n    /**\n     * we can split the listeners with the system\n     * namespace... and type (aka identifier criteria)\n     */\n    protected messageListeners: any = {};\n    protected subjects: any = {};\n    protected processedMessages: any = {};\n\n    protected cleanupCnt = 0;\n    protected rootElem;\n    protected msgHandler;\n\n    protected readonly TIMEOUT_IN_MS = 1000;\n    protected readonly MSG_EVENT = \"message\";\n\n\n    abstract register(scopeElement?: any);\n\n    abstract unregister();\n\n    abstract broadcast(channel: string, message: Message | string);\n\n\n    /**\n     * registers a listener on a channel\n     * @param channel the channel to register the listeners for\n     * @param listener the listener to register\n     */\n    registerListener(channel: string, listener: (msg: Message) => void) {\n        this.reserveListenerNS(channel);\n\n        //we skip the processed messages, because they originated here\n        //and already are processed\n        this.messageListeners[channel].push((msg: Message) => {\n            if (msg.identifier in this.processedMessages) {\n                return;\n            }\n            listener(msg);\n        });\n    }\n\n    /**\n     * binding into rxjs\n     * produces a subject which can be used via next calls to send messages\n     * on the other hand we\n     * @param channel\n     */\n    asSubject(channel: string): Subject<Message> {\n        this.reserveSubjectNS(channel);\n        let subject = this.subjects[channel];\n        let oldNext = subject.next;\n        let lastMsg = null;\n        subject.next = (msg: Message | MessageWrapper) => {\n            //We use a recursive call to let the broadcaster handle\n            //The wrapper conversion and then again call us here\n            //that way both directions are handled.. next calls the broker\n            //and a broadcast calls next\n            if((<MessageWrapper>msg)?.detail) {\n                oldNext.call(subject, (<MessageWrapper>msg)?.detail);\n            } else {\n                this.broadcast(channel, <Message> msg);\n            }\n        }\n        return subject;\n    }\n\n    /**\n     * returns an observable on the baseBroker\n     * @param channel\n     */\n    asObservable(channel: string): Observable<Message> {\n        return this.asSubject(channel).asObservable();\n    }\n\n    /**\n     * reserves the listener namespace and wildcard namespace for the given identifier\n     * @param identifier\n     * @private\n     */\n    private reserveListenerNS(identifier: string) {\n        if (!this.messageListeners[identifier]) {\n            this.messageListeners[identifier] = [];\n        }\n        if (!this.messageListeners[\"*\"]) {\n            this.messageListeners[\"*\"] = [];\n        }\n    }\n\n    private reserveSubjectNS(identifier: string) {\n        if (!this.subjects[identifier]) {\n            this.subjects[identifier] = new Subject();\n        }\n        if (!this.subjects[\"*\"]) {\n            this.subjects[\"*\"] = new Subject();\n        }\n    }\n\n    /**\n     * unregisters a listener from this channel\n     *\n     * @param channel the channel to unregister from\n     * @param listener the listener to unregister the channel from\n     */\n    unregisterListener(channel: string, listener: (msg: Message) => void) {\n        this.messageListeners[channel] = (this.messageListeners[channel] || []).filter((item: any) => item !== listener);\n    }\n\n    /**\n     * answers a bidirectional message received\n     * usage, the client can use this method, to answer an incoming message in a precise manner\n     * so that the caller sending the bidirectional message knows how to deal with it\n     * this mechanism can be used for global storages where we have one answering entity per channel delivering the\n     * requested data, the request can be done asynchronously via promises waiting for answers\n     *\n     * @param channel the channel the originating message\n     * @param request the requesting message\n     * @param answer the answer to the request\n     */\n    answer(channel: string, request: Message |string, answer: Message) {\n        if('string' == typeof request) {\n            request = new Message(request);\n        }\n\n        if (BaseBroker.isAnswer(request)) {\n            return;\n        }\n        answer.identifier = BaseBroker.getAnswerId(request);\n        this.broadcast(channel, answer);\n    }\n\n    private static getAnswerId(request: Message) {\n        return \"_r_\" + request.identifier;\n    }\n\n    private static isAnswer(request: Message) {\n        return request.identifier.indexOf(\"_r_\") == 0;\n    }\n\n    /**\n     * idea... a bidirectional broadcast\n     * sends a message and waits for the first answer coming in from one of the receivers\n     * sending the message back with a messageIdentifier_broadCastId answer\n     *\n     * @param channel\n     * @param message\n     */\n    request(channel: string, message: Message | string): Promise<Message> {\n        if('string' == typeof message) {\n            message = new Message(message);\n        }\n        let messageId = message.identifier;\n\n        let ret = new Promise<Message>((resolve, reject) => {\n            let timeout = null;\n            let listener = (message2: Message) => {\n                if (message2.identifier == messageId) {\n                    //broadcast from same source, we do not want\n                    //to deal with it now\n                    return;\n                }\n\n                if (message2.identifier == \"_r_\" + messageId) {\n                    clearTimeout(timeout);\n                    this.unregisterListener(channel, listener);\n                    resolve(message2);\n                }\n            }\n            timeout = setTimeout(() => {\n                this.unregisterListener(channel, listener);\n                reject(\"request message performed, timeout, no return value\");\n            }, 3000);\n            this.registerListener(channel, listener);\n\n        });\n        this.broadcast(channel, message);\n        return ret;\n    }\n\n\n    /**\n     * garbage collects the processed messages queue\n     * usually after one second\n     */\n    protected gcProcessedMessages() {\n        if ((++this.cleanupCnt) % 10 != 0) {\n            return;\n        }\n        let newProcessedMessages: any = {};\n        Object.keys(this.processedMessages).forEach(key => {\n            if (this.messageStillActive(key)) return;\n            newProcessedMessages[key] = this.processedMessages[key];\n        });\n        this.processedMessages = newProcessedMessages;\n    }\n\n    private messageStillActive(key: string): boolean {\n        return this.processedMessages[key] > ((new Date()).getMilliseconds() - this.TIMEOUT_IN_MS);\n    }\n\n    protected markMessageAsProcessed(message: Message) {\n        this.processedMessages[message.identifier] = message.creationDate;\n    }\n}\n\n/**\n * a broker which hooks into the Broadcast Channel broker\n * either via shim or substitute lib\n */\nexport class BroadcastChannelBroker extends BaseBroker {\n    private openChannels: [{ key: string }, BroadcastChannel] = <any>{};\n    private readonly msgListener: Function;\n\n\n    /**\n     * @param brokerFactory a factory generating a broker\n     * @param channelGroup a group to combine a set of channels\n     */\n    constructor(private brokerFactory: Function = (name) => {\n        if (window?.BroadcastChannel) {\n            return new window.BroadcastChannel(name);\n        }\n        throw Error(\"No Broadcast channel in the system, use a shim or provide a factory function\" +\n            \"in the constructor\");\n    }, private channelGroup = \"brokr\") {\n        super();\n        this.msgListener = (messageData: MessageWrapper) => {\n            let coreMessage = messageData.detail;\n            let channel: string = messageData.channel;\n\n            if (this.messageListeners?.[channel]) {\n                this.messageListeners?.[channel].forEach(listener => {\n                    listener(coreMessage);\n                })\n            }\n            this.markMessageAsProcessed(coreMessage);\n            return true;\n        }\n        this.register();\n    }\n\n    broadcast(channel: string, message: Message | string, includeOrigin = true) {\n        try {\n            if('string' == typeof message) {\n                message = new Message(message);\n            }\n            //we now run a quick remapping to avoid\n            //serialisation errors\n            let msgString = JSON.stringify(<Message> message);\n            message = <Message> JSON.parse(msgString);\n\n            let messageWrapper = new MessageWrapper(channel, message);\n\n            if(this?.subjects[channel]) {\n                this.subjects[channel].next(messageWrapper);\n            }\n\n            this.openChannels[this.channelGroup].postMessage(messageWrapper);\n            if (includeOrigin) {\n                this.msgListener(messageWrapper);\n            }\n        } finally {\n            this.gcProcessedMessages();\n        }\n    }\n\n\n\n\n\n    registerListener(channel: string, listener: (msg: Message) => void) {\n        super.registerListener(channel, listener);\n    }\n\n    register() {\n        if(!this.openChannels[this.channelGroup]) {\n            this.openChannels[this.channelGroup] = this.brokerFactory(this.channelGroup);\n        }\n        this.openChannels[this.channelGroup].addEventListener(\"message\", this.msgListener);\n    }\n\n    unregister() {\n        this.openChannels[this.channelGroup].close();\n    }\n}\n\n\n/**\n * implementation of a messaging based transport\n */\n\n/**\n * central message broker which uses various dom constructs\n * to broadcast messages into subelements\n *\n * we use the dom event system as transport and iframe and shadow dom mechanisms in a transparent way to\n * pull this off\n *\n * usage\n *\n * broker = new Broker(optional rootElement)\n *\n * defines a message broker within a scope of rootElement (without it is window aka the current isolation level)\n *\n * broker.registerListener(channel, listener) registers a new listener to the current broker and channel\n * broker.unregisterListener(channel, listener) unregisters the given listener\n *\n * broker.broadcast(message, optional direction, optional callBrokerListeners)\n * sends a message (channel included in the message object) in a direction (up, down, both)\n * and also optionally calls the listeners on the same broker (default off)\n *\n * the flow is like\n * up messages are propagated upwards only until it reaches the outer top of the dom\n * downwards, the messages are propagated downwards only\n * both the message is propagated into both directions\n *\n * Usually messages sent from the same broker are not processed within... however by setting\n * callBrokerListeners to true the listeners on the same broker also are called\n * brokers on the same level will get the message and process it automatically no matter what.\n * That way you can exclude the source from message processing (and it is done that way automatically)\n *\n * Isolation levels. Usually every isolation level needs its own broker object registering\n * on the outer bounds\n *\n * aka documents will register on window\n * iframes on the iframe windowObject\n * isolated shadow doms... document\n *\n *\n *\n */\nexport class Broker extends BaseBroker {\n\n    /**\n     * constructor has an optional root element\n     * and an internal name\n     *\n     * @param scopeElement\n     * @param name\n     */\n    constructor(scopeElement: HTMLElement | Window | ShadowRoot = window, public name = \"brokr\") {\n\n        super();\n\n        /**\n         * message relay.. identifies message events and relays them to the listeners\n         * @param event\n         */\n        let evtHandler = (event: MessageEvent | CustomEvent<Message>) => {\n            let details = (<any>event)?.detail ?? (<MessageEvent>event)?.data?.detail;\n            let channel = ((<any>event)?.data?.channel) ?? ((<any>event)?.channel);\n\n            //javascript loses the type info in certain module types\n            if (details?.identifier && details?.message) {\n                let msg: Message = details;\n                if (msg.identifier in this.processedMessages) {\n                    return;\n                }\n                //coming in from up... we need to send it down\n                //a relayed message always has to trigger the listeners as well\n                this.broadcast(channel, msg);\n            }\n        };\n        this.msgHandler = (evt: MessageEvent) => evtHandler(evt);\n        this.register(scopeElement);\n    }\n\n    /**\n     * register the current broker into a scope defined by wnd\n     * @param scopeElement\n     */\n    register(scopeElement: HTMLElement | Window | ShadowRoot) {\n        this.rootElem = (<any>scopeElement).host ? (<any>scopeElement).host : scopeElement;\n        if ((<any>scopeElement).host) {\n            let host = (<ShadowRoot>scopeElement).host;\n            host.setAttribute(\"data-broker\", \"1\");\n        } else {\n            if (scopeElement?.[\"setAttribute\"])\n                (<any>scopeElement).setAttribute(\"data-broker\", \"1\");\n        }\n\n        this.rootElem.addEventListener(Broker.EVENT_TYPE, this.msgHandler, {capture: true});\n        /*dom message usable by iframes*/\n        this.rootElem.addEventListener(this.MSG_EVENT, this.msgHandler, {capture: true});\n    }\n\n    /**\n     * manual unregister function, to unregister as broker from the current\n     * scope\n     */\n    unregister() {\n        this.rootElem.removeEventListener(Broker.EVENT_TYPE, this.msgHandler)\n        this.rootElem.removeEventListener(this.MSG_EVENT, this.msgHandler)\n    }\n\n\n    /**\n     * broadcast a message\n     * the message contains the channel and the data and some internal bookkeeping data\n     *\n     * @param channel the channel to broadcast to\n     * @param message the message dot send\n     * (for instance 2 iframes within the same parent broker)\n     *\n     */\n    broadcast(channel: string, message: Message | string) {\n        if('string' == typeof message) {\n            message = new Message(message);\n        }\n\n        if(this?.subjects[channel]) {\n            this.subjects[channel].next(new MessageWrapper(channel, message));\n        }\n\n        try {\n            this.dispatchUp(channel, message, false, true);\n            //listeners already called\n            this.dispatchDown(channel, message, true, false)\n        } finally {\n            this.gcProcessedMessages();\n        }\n    }\n\n    private dispatchUp(channel: string, message: Message, ignoreListeners = true, callBrokerListeners = true) {\n        if (!ignoreListeners) {\n            this.msgCallListeners(channel, message);\n        }\n        this.markMessageAsProcessed(message);\n        if (window.parent != null) {\n\n            let messageWrapper = new MessageWrapper(channel, message);\n            window.parent.postMessage(JSON.parse(JSON.stringify(messageWrapper)), message.targetOrigin);\n        }\n        if (callBrokerListeners) {\n            Broker.dispatchSameLevel(channel, message);\n        }\n    }\n\n    private static dispatchSameLevel(channel: string, message: Message) {\n        let event = Broker.transformToEvent(channel, message, true);\n        //we also dispatch sideways\n        window.dispatchEvent(event);\n    }\n\n    //a dispatch of our own should never trigger the listeners hence the default true\n    private dispatchDown(channel: string, message: Message, ignoreListeners = true, callBrokerListeners = true) {\n        if (!ignoreListeners) {\n            this.msgCallListeners(channel, message);\n        }\n        this.processedMessages[message.identifier] = message.creationDate;\n        let evt = Broker.transformToEvent(channel, message);\n\n        /*we now notify all iframes lying underneath */\n        Array.prototype.slice.call(document.querySelectorAll(\"iframe\")).forEach((element: HTMLIFrameElement) => {\n            let messageWrapper = new MessageWrapper(channel, message);\n            element.contentWindow.postMessage(JSON.parse(JSON.stringify(messageWrapper)), message.targetOrigin);\n        });\n\n        Array.prototype.slice.call(document.querySelectorAll(\"[data-broker='1']\")).forEach((element: HTMLElement) => element.dispatchEvent(evt))\n\n        if (callBrokerListeners) {\n            Broker.dispatchSameLevel(channel, message);\n        }\n    }\n\n\n    private msgCallListeners(channel: string, message: Message) {\n        let listeners = this.messageListeners[channel];\n        if (listeners?.length) {\n            let callElement = (element: (msg: Message) => void) => {\n                element(message);\n            }\n\n            listeners.forEach(callElement);\n        }\n    }\n\n    private static transformToEvent(channel: string, message: Message, bubbles = false): CustomEvent {\n        let messageWrapper = new MessageWrapper(channel, message);\n        messageWrapper.bubbles = bubbles;\n        return Broker.createCustomEvent(Broker.EVENT_TYPE, messageWrapper);\n    }\n\n    private static createCustomEvent(name: string, wrapper: MessageWrapper): any {\n        if ('function' != typeof window.CustomEvent) {\n            let e: any = document.createEvent('HTMLEvents');\n            e.detail = wrapper.detail;\n            e.channel = wrapper.channel;\n            e.initEvent(name, wrapper.bubbles, wrapper.cancelable);\n            return e;\n\n        } else {\n            let customEvent = new window.CustomEvent(name, wrapper);\n            (<any>customEvent).channel = wrapper.channel;\n            return customEvent;\n        }\n\n    }\n}","module.exports = require(\"rxjs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(493);\n"],"names":["message","targetOrigin","this","creationDate","Date","getMilliseconds","identifier","Math","random","Message","channel","detail","bubbles","cancelable","composed","messageListeners","subjects","processedMessages","cleanupCnt","TIMEOUT_IN_MS","MSG_EVENT","registerListener","listener","reserveListenerNS","push","msg","asSubject","reserveSubjectNS","subject","oldNext","next","call","broadcast","asObservable","Subject","unregisterListener","filter","item","answer","request","BaseBroker","isAnswer","getAnswerId","indexOf","messageId","ret","Promise","resolve","reject","timeout","message2","clearTimeout","setTimeout","gcProcessedMessages","newProcessedMessages","Object","keys","forEach","key","messageStillActive","markMessageAsProcessed","EVENT_TYPE","brokerFactory","channelGroup","name","window","BroadcastChannel","Error","openChannels","msgListener","messageData","coreMessage","register","includeOrigin","msgString","JSON","stringify","parse","messageWrapper","MessageWrapper","postMessage","addEventListener","unregister","close","BroadcastChannelBroker","scopeElement","msgHandler","evt","event","details","data","evtHandler","rootElem","host","setAttribute","Broker","capture","removeEventListener","dispatchUp","dispatchDown","ignoreListeners","callBrokerListeners","msgCallListeners","parent","dispatchSameLevel","transformToEvent","dispatchEvent","Array","prototype","slice","document","querySelectorAll","element","contentWindow","listeners","length","createCustomEvent","wrapper","CustomEvent","e","createEvent","initEvent","customEvent","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}