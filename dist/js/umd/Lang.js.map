{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///src/main/typescript/Users/werpu2/development/workspace/monadish/src/main/typescript/Monad.ts","webpack:///src/main/typescript/Users/werpu2/development/workspace/monadish/src/main/typescript/Lang.ts","webpack:///src/main/typescript/Users/werpu2/development/workspace/monadish/src/main/typescript/Promise.ts"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Monad","this","_value","fn","inval","result","mapped","map","Stream","data","cnt","length","res","each","item","push","mapStreams","startVal","offset","val1","Optional","fromNullable","absent","matches","concat","super","isAbsent","elseValue","isPresent","flatMap","func","val","getClass","currentPos","currKey","keyVal","arrPos","arrayIndex","Array","getIfPresent","defaultVal","JSON","stringify","start","indexOf","end","parseInt","substring","ConfigEntry","rootElem","Config","keys","buildPath","getIf","apply","slice","condition","maps","overwrite","retVal","arrForEach","mixMaps","mergeMaps","parentVal","parentPos","alloc","arr","setVal","tempVal","Lang","_instance","it","splitter","retArr","split","trim","ret","len","str","ws","replace","test","charAt","arguments","String","Function","scope","method","blockFilter","whitelistFilter","dest","src","obj","pack","finalOffset","finalPack","e","callbackfn","startPos","startPosFinal","thisObj","convertedArr","objToArray","forEach","Error","arrIndexOf","element","fromIndex","pos","arrFinal","filter","args","argNames","UDEF","source","destination","toLowerCase","timeout","handler","reject","setTimeout","clearTimeout","setInterval","clearInterval","probe","theType","isString","resolverProducer","defaultValue","PromiseStatus","Promise","executor","status","PENDING","allFuncs","resolve","promises","myapply","promiseCnt","myPromise","__last__","finally","myreject","thenexecutor","catchexeutor","then","catch","reason","executorFunc","catchfunc","spliceLastFuncs","__reason__","lastFuncs","rest","shift","funcResult","transferIntoNewPromise","appyFinally","FULLFILLED","REJECTED","CancellablePromise","cancellator"],"mappings":"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","file":"Lang.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/* Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A module which keeps  basic monadish like definitions in place without any sidedependencies to other modules.\n * Useful if you need the functions in another library to keep its dependencies down\n */\n\n/*IMonad definitions*/\n\n\n\n/**\n * IFunctor interface,\n * defines an interface which allows to map a functor\n * via a first order function to another functor\n */\nexport interface IFunctor<T> {\n    map<R>(fn: (data: T) => R): IFunctor<R>;\n}\n\n/**\n * IMonad definition, basically a functor with a flaptmap implementation (flatmap reduces all nested monads after a\n * function call f into a monad with the nesting level of 1\n *\n * flatmap flats nested Monads into a IMonad of the deepest nested implementation\n */\nexport interface IMonad<T, M extends IMonad<any, any>> extends IFunctor<T> {\n    flatMap<T, M>(f: (T) => M): IMonad<any, any>;\n}\n\n/**\n * a stateful functor which holds a value upn which a\n * function can be applied\n *\n * as value holder of type T\n */\nexport interface IIdentity<T> extends IFunctor<T> {\n    readonly value: T;\n}\n\n/**\n *  custom value holder definition, since we are not pure functional\n *  but iterative we have structures which allow the assignment of a value\n *  also not all structures are sideffect free\n */\nexport interface IValueHolder<T> {\n    value: T | Array<T>;\n}\n\n/**\n * Implementation of a monad\n * (Sideffect free), no write allowed directly on the monads\n * value state\n */\nexport class Monad<T> implements IMonad<T, Monad<any>>, IValueHolder<T> {\n    protected _value: T;\n\n    constructor(value: T) {\n        this._value = value;\n    }\n\n    map<R>(fn?: (data: T) => R): Monad<R> {\n        if (!fn) {\n            fn = (inval: any) => <R>inval;\n        }\n        let result: R = fn(this.value);\n        return new Monad(result);\n    }\n\n    flatMap<R>(fn?: (data: T) => R): Monad<any> {\n        let mapped: Monad<any> = this.map(fn);\n        while (\"undefined\" != typeof mapped && mapped != null && mapped.value instanceof Monad) {\n            mapped = mapped.value\n        }\n        return mapped;\n    }\n\n\n    get value(): T {\n        return this._value;\n    }\n\n}\n\n/*\n * A small stream implementation\n */\nexport class Stream<T> implements IMonad<T, Stream<any>>, IValueHolder<Array<T>>{\n\n    static of<T>(... data: Array<T>): Stream<T> {\n        return new Stream<T>(... data);\n    }\n\n    value: Array<T>;\n    constructor(...value: T[]){\n        this.value = value;\n    }\n\n    each(fn: (data: T, pos ?: number) => void | boolean) {\n        for(let cnt = 0; cnt < this.value.length ; cnt++) {\n            if(fn(this.value[cnt], cnt) === false) {\n                break;\n            }\n        }\n        return this;\n    }\n\n    map<R>(fn?: (data: T) => R): Stream<R> {\n        if (!fn) {\n            fn = (inval: any) => <R>inval;\n        }\n        let res: R[] = [];\n        this.each((item, cnt) => {\n            res.push(fn(item))\n        });\n\n        return new Stream<R>(...res);\n    }\n\n    /*\n     * we need to implement it to fullfill the contract, although it is used only internally\n     * all values are flattened when accessed anyway, so there is no need to call this methiod\n     */\n    flatMap<R>(fn?: (data: T) => R): Stream<any> {\n        let mapped:Stream<R> = this.map(fn);\n        let res = this.mapStreams(mapped);\n        return new Stream(...res);\n    }\n\n    filter(fn?: (data: T) => boolean): Stream<T> {\n        let res: Array<T> = [];\n        this.each((data) => {\n            if(fn(data)) {\n                res.push(data);\n            }\n        });\n        return new Stream<T>(...res);\n    }\n\n    reduce(fn: (val1: T, val2:T) => T, startVal: T = null): Optional<T> {\n        let offset = startVal != null ? 0 : 1;\n        let val1 = startVal != null ? startVal : this.value.length ? this.value[0] : null;\n\n        for(let cnt = offset; cnt < this.value.length; cnt++) {\n            val1 = fn(val1, this.value[cnt]);\n        }\n        return Optional.fromNullable(val1);\n    }\n\n    first(): Optional<T> {\n        return this.value && this.value.length ? Optional.fromNullable(this.value[0]) : Optional.absent;\n    }\n\n\n    last(): Optional<T> {\n        //could be done via reduce, but is faster this way\n        return Optional.fromNullable(this.value.length ? this.value[this.value.length -1] : null);\n    }\n\n    anyMatch(fn: (data: T) => boolean): boolean {\n        for(let cnt = 0; cnt < this.value.length; cnt++) {\n            if(fn(this.value[cnt])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    allMatch(fn: (data: T) => boolean): boolean {\n        if(!this.value.length) {\n            return false;\n        }\n        let matches = 0;\n        for(let cnt = 0; cnt < this.value.length; cnt++) {\n            if(fn(this.value[cnt])) {\n                matches++;\n            }\n        }\n        return matches == this.value.length;\n    }\n\n    noneMatch(fn: (data: T) => boolean): boolean {\n        let matches = 0;\n        for(let cnt = 0; cnt < this.value.length; cnt++) {\n            if(fn(this.value[cnt])) {\n                matches++;\n            }\n        }\n        return matches == this.value.length;\n    }\n\n    private mapStreams<R>(mapped: Stream<R>): Array<R> {\n        let res: Array<R> = [];\n        mapped.each((data: any) => {\n            if (data instanceof Stream) {\n                res = res.concat(this.mapStreams(data));\n            } else {\n                res.push(data);\n            }\n        });\n        return res;\n    }\n}\n\n/**\n * optional implementation, an optional is basically an implementation of a Monad with additional syntactic\n * sugar on top\n * (Sideeffect free, since value assignment is not allowed)\n * */\nexport class Optional<T> extends Monad<T> {\n\n\n    constructor(value: T) {\n        super(value);\n    }\n\n    static fromNullable<T>(value?: T): Optional<T> {\n        return new Optional(value);\n    }\n\n    /*default value for absent*/\n    static absent = Optional.fromNullable(null);\n\n    /*syntactic sugar for absent and present checks*/\n    isAbsent(): boolean {\n        return \"undefined\" == typeof this.value || null == this.value;\n    }\n\n    isPresent(): boolean {\n        return !this.isAbsent();\n    }\n\n    orElse(elseValue: any): Optional<any> {\n        if (this.isPresent()) {\n            return this;\n        } else {\n            //shortcut\n            if(elseValue == null) {\n                return Optional.absent;\n            }\n            return this.flatMap(() => elseValue);\n        }\n    }\n\n    /**\n     * lazy, passes a function which then is lazily evaluated\n     * instead of a direct value\n     * @param func\n     */\n    orElseLazy(func: () => any): Optional<any> {\n        if (this.isPresent()) {\n            return this;\n        } else {\n            return this.flatMap(func);\n        }\n    }\n\n    /*\n     * we need to implement it to fullfill the contract, although it is used only internally\n     * all values are flattened when accessed anyway, so there is no need to call this methiod\n     */\n    flatMap<R>(fn?: (data: T) => R): Optional<any> {\n        let val = super.flatMap(fn);\n        if (!(val instanceof Optional)) {\n            return Optional.fromNullable(val.value);\n        }\n\n        return <Optional<any>> val.flatMap();\n    }\n\n    /**\n     * additional syntactic sugar which is not part of the usual optional implementation\n     * but makes life easier, if you want to sacrifice typesafety and refactoring\n     * capabilities in typescript\n     */\n    private getIfPresent<R>(key: string): Optional<R> {\n        if (this.isAbsent()) {\n            return this.getClass().absent;\n        }\n        return this.getClass().fromNullable(this.value[key]).flatMap();\n    }\n\n\n    /*\n     * elvis operation, take care, if you use this you lose typesafety and refactoring\n     * capabilites, unfortunately typesceript does not allow to have its own elvis operator\n     * this is some syntactic sugar however which is quite useful*/\n    getIf<R>(...key: string[]): Optional<R> {\n\n        let currentPos: Optional<any> = this;\n        for (let cnt = 0; cnt < key.length; cnt++) {\n            let currKey = this.keyVal(key[cnt]);\n            let arrPos = this.arrayIndex(key[cnt]);\n\n            if (currKey === \"\" && arrPos >= 0) {\n                currentPos = this.getClass().fromNullable(!(currentPos.value instanceof Array ) ? null : (currentPos.value.length < arrPos ? null : currentPos.value[arrPos]));\n                if (currentPos.isAbsent()) {\n                    return currentPos;\n                }\n                continue;\n            } else if (currKey && arrPos >= 0) {\n                if (currentPos.getIfPresent(currKey).isAbsent()) {\n                    return currentPos;\n                }\n                currentPos = (currentPos.getIfPresent(currKey).value instanceof Array) ? this.getClass().fromNullable(currentPos.getIfPresent(currKey).value[arrPos]) : this.getClass().absent;\n                if (currentPos.isAbsent()) {\n                    return currentPos;\n                }\n                continue;\n\n            } else {\n                currentPos = currentPos.getIfPresent(currKey);\n            }\n            if (currentPos.isAbsent()) {\n                return currentPos;\n            } else if (arrPos > -1) {\n                currentPos = this.getClass().fromNullable(currentPos.value[arrPos]);\n            }\n        }\n        let retVal = currentPos;\n\n        return retVal;\n    }\n\n    get value(): T {\n        if (this._value instanceof Monad) {\n            return this._value.flatMap().value\n        }\n        return this._value;\n    }\n\n    /**\n     * simple match, if the first order function call returns\n     * true then there is a match, if the value is not present\n     * it never matches\n     *\n     * @param fn the first order function performing the match\n     */\n    match(fn: (item: T) => boolean): boolean {\n        if(this.isAbsent()) {\n            return false\n        }\n        return fn(this.value);\n    }\n\n    /**\n     * convenience function to flatmap the internal value\n     * and replace it with a default in case of being absent\n     *\n     * @param defaultVal\n     * @returns {Optional<any>}\n     */\n    get<R>(defaultVal: any = Optional.absent): Optional<R> {\n        if (this.isAbsent()) {\n            return this.getClass().fromNullable(defaultVal).flatMap();\n        }\n\n        return this.getClass().fromNullable(this.value).flatMap();\n    }\n\n    /**\n     * helper to override several implementations in a more fluent way\n     * by having a getClass operation we can avoid direct calls into the constructor or\n     * static methods and do not have to implement several methods which rely on the type\n     * of \"this\"\n     * @returns {Monadish.Optional}\n     */\n    protected getClass(): any {\n        return Optional;\n    }\n\n    toJson(): string {\n        return JSON.stringify(this.value);\n    }\n\n    /*helper method for getIf with array access aka <name>[<indexPos>]*/\n    protected arrayIndex(key: string): number {\n        let start = key.indexOf(\"[\");\n        let end = key.indexOf(\"]\");\n        if (start >= 0 && end > 0 && start < end) {\n            return parseInt(key.substring(start + 1, end));\n        } else {\n            return -1;\n        }\n    }\n\n    /*helper method for getIf with array access aka <name>[<indexPos>]*/\n    protected keyVal(key: string): string {\n        let start = key.indexOf(\"[\");\n\n        if (start >= 0) {\n            return key.substring(0, start);\n        } else {\n            return key;\n        }\n    }\n\n\n}\n\n\n/**\n * helper class to allow write access to the config\n * in certain situations (after an apply call)\n */\nclass ConfigEntry<T> implements IValueHolder<T> {\n    rootElem: any;\n    key: any;\n    arrPos: number;\n\n\n    constructor(rootElem: any, key: any, arrPos?: number) {\n        this.rootElem = rootElem;\n        this.key = key;\n        this.arrPos = (\"undefined\" != typeof arrPos) ? arrPos : -1;\n    }\n\n    get value() {\n        if (this.key == \"\" && this.arrPos >= 0) {\n            return this.rootElem[this.arrPos];\n        } else if (this.key && this.arrPos >= 0) {\n            return this.rootElem[this.key][this.arrPos];\n        }\n        return this.rootElem[this.key];\n    }\n\n    set value(val: T) {\n        if (this.key == \"\" && this.arrPos >= 0) {\n            this.rootElem[this.arrPos] = val;\n            return;\n        } else if (this.key && this.arrPos >= 0) {\n            this.rootElem[this.key][this.arrPos] = val;\n            return;\n        }\n        this.rootElem[this.key] = val;\n    }\n}\n\n/**\n * Config, basically an optional wrapper for a json structure\n * (not sideeffect free, since we can alter the internal config state\n * without generating a new config), not sure if we should make it sideffect free\n * since this would swallow a lot of performane and ram\n */\nexport class Config extends Optional<any> {\n    constructor(root: any) {\n        super(root);\n    }\n\n    static fromNullable<T>(value?: any): Config {\n        return new Config(value);\n    }\n\n    apply(...keys: Array<any>): IValueHolder<any> {\n        if (keys.length < 1) {\n            return;\n        }\n\n        this.buildPath(keys);\n\n        let currKey = this.keyVal(keys[keys.length - 1]);\n        let arrPos = this.arrayIndex(keys[keys.length - 1]);\n        let retVal = new ConfigEntry(keys.length == 1 ? this.value : this.getIf.apply(this, keys.slice(0, keys.length - 1)).value,\n            currKey, arrPos\n        );\n\n        return retVal;\n    }\n\n\n    applyIf(condition: boolean,...keys: Array<any>): IValueHolder<any> {\n        return  condition ? this.apply(keys) : {value: null};\n    }\n\n\n\n    getIf(...keys: Array<string>): Config {\n        return this.getClass().fromNullable(super.getIf.apply(this, keys).value);\n    }\n\n    get(defaultVal: any): Config {\n        return this.getClass().fromNullable(super.get(defaultVal).value);\n    }\n\n    //empties the current config entry\n    delete(key: string): Config {\n        if(key in this.value) {\n            delete this.value[key];\n        }\n        return this;\n    }\n\n    toJson(): any {\n        return JSON.stringify(this.value);\n    }\n\n    get shallowCopy(): Config {\n        let mergeMaps = function(maps: any[], overwrite = true) {\n            let retVal = {};\n            this.arrForEach(maps, (item:{[key:string]:any})  => {\n                this.mixMaps(retVal, item, overwrite)\n            });\n            return retVal;\n        }\n        return new Config(mergeMaps([{}, this.value || {}]));\n    }\n\n    protected getClass(): any {\n        return Config;\n    }\n\n    private setVal(val: any) {\n        this._value = val;\n    }\n\n    private buildPath(keys: Array<any>): Config {\n        let val = this;\n        let parentVal = this.getClass().fromNullable(null);\n        let parentPos = -1;\n        let alloc = function (arr: Array<any>, length: number) {\n            if (arr.length < length) {\n                for (let cnt = arr.length; cnt < length; cnt++) {\n                    arr.push({});\n                }\n            }\n        };\n\n\n        for (let cnt = 0; cnt < keys.length; cnt++) {\n            let currKey = this.keyVal(keys[cnt]);\n            let arrPos = this.arrayIndex(keys[cnt]);\n\n            if (currKey === \"\" && arrPos >= 0) {\n\n                val.setVal((val.value instanceof Array) ? val.value : []);\n                alloc(val.value, arrPos + 1);\n                if (parentPos >= 0) {\n                    parentVal.value[parentPos] = val.value;\n                }\n                parentVal = val;\n                parentPos = arrPos;\n                val = this.getClass().fromNullable(val.value[arrPos]);\n                continue;\n            }\n\n            let tempVal = <Config> val.getIf(currKey);\n            if (arrPos == -1) {\n                if (tempVal.isAbsent()) {\n                    tempVal = <Config> this.getClass().fromNullable(val.value[currKey] = {});\n                } else {\n                    val = <any>tempVal;\n                }\n            } else {\n                let arr = (tempVal.value instanceof Array) ? tempVal.value : [];\n                alloc(arr, arrPos + 1);\n                val.value[currKey] = arr;\n                tempVal = this.getClass().fromNullable(arr[arrPos]);\n            }\n            parentVal = val;\n            parentPos = arrPos;\n            val = <any>tempVal;\n        }\n\n        return this;\n    }\n}\n\n\n\n/*we do not implenent array, maps etc.. monads there are libraries like lodash which have been doing that for ages*/\n\n","/* Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {CancellablePromise} from \"./Promise\";\nimport {Optional} from \"./Monad\";\n\n/**\n * Lang helpers crossported from the apache myfaces project\n */\nexport class Lang {\n\n    private static _instance: Lang;\n\n    static get instance() {\n        if (!Lang._instance) {\n            Lang._instance = new Lang();\n        }\n        return Lang._instance;\n    }\n\n    /**\n     * String to array function performs a string to array transformation\n     * @param {String} it the string which has to be changed into an array\n     * @param {RegExp} splitter our splitter reglar expression\n     * @return an array of the splitted string\n     */\n    strToArray(it: string, splitter: string | RegExp = /\\./gi): Array<string> {\n        //\tsummary:\n        //\t\tReturn true if it is a String\n\n        let retArr = it.split(splitter);\n        for (let cnt = 0; cnt < retArr.length; cnt++) {\n            retArr[cnt] = this.trim(retArr[cnt]);\n        }\n        return retArr;\n    }\n\n    arrToMap(arr:any[], offset: number = 0) {\n        var ret = new Array(arr.length);\n        var len = arr.length;\n        offset = (offset) ? offset : 0;\n        for (var cnt = 0; cnt < len; cnt++) {\n            ret[arr[cnt]] = cnt + offset;\n        }\n        return ret;\n    }\n\n    /**\n     * hyperfast trim\n     * http://blog.stevenlevithan.com/archives/faster-trim-javascript\n     * crossported from dojo\n     */\n    trim(str: string): string {\n        str = str.replace(/^\\s\\s*/, '');\n        let ws = /\\s/, i = str.length;\n\n        while (ws.test(str.charAt(--i))) {\n            //do nothing\n        }\n        return str.slice(0, i + 1);\n    }\n\n\n    /**\n     * Backported from dojo\n     * a failsafe string determination method\n     * (since in javascript String != \"\" typeof alone fails!)\n     * @param it {|Object|} the object to be checked for being a string\n     * @return true in case of being a string false otherwise\n     */\n    isString(it?: any): boolean {\n        //\tsummary:\n        //\t\tReturn true if it is a String\n        return !!arguments.length && it != null && (typeof it == \"string\" || it instanceof String); // Boolean\n    }\n\n    isFunc(it: any): boolean {\n        return it instanceof  Function || typeof it === \"function\";\n    }\n\n    /**\n     * hitch backported from dojo\n     * hitch allows to assign a function to a dedicated scope\n     * this is helpful in situations when function reassignments\n     * can happen\n     * (notably happens often in lazy xhr code)\n     *\n     * @param {Function} scope of the function to be executed in\n     * @param {Function} method to be executed, the method must be of type function\n     *\n     * @return whatever the executed method returns\n     *\n     */\n    hitch(scope: any, method: Function): Function {\n        return !scope ? method : function () {\n            return method.apply(scope, arguments || []);\n        }; // Function\n    }\n\n    /**\n     * simplified merge maps which basically produces\n     * a final merged map from left to right\n     * the function is sideffect free\n     * @param maps\n     */\n    mergeMaps(maps: {[key:string]:any}[], overwrite: boolean = true, blockFilter?: Function, whitelistFilter?: Function): {[key:string]:any} {\n        let retVal = {};\n        this.arrForEach(maps, (item:{[key:string]:any})  => {\n            this.mixMaps(retVal, item, overwrite)\n        });\n        return retVal;\n    }\n\n    /**\n     * Helper function to merge two maps\n     * into one\n     * @param {Object} dest the destination map\n     * @param {Object} src the source map\n     * @param {boolean} overwrite if set to true the destination is overwritten if the keys exist in both maps\n     * @param blockFilter\n     * @param whitelistFilter\n     **/\n    mixMaps<T>(dest: { [key: string]: T }, src: { [key: string]: T }, overwrite: boolean, blockFilter?: Function, whitelistFilter?: Function): { [key: string]: T } {\n        let UNDEF = \"undefined\";\n        for (let key in src) {\n            if (!src.hasOwnProperty(key)) continue;\n            if (blockFilter && blockFilter[key]) {\n                continue;\n            }\n            if (whitelistFilter && !whitelistFilter[key]) {\n                continue;\n            }\n            if (!overwrite) {\n                /**\n                 *we use exists instead of booleans because we cannot rely\n                 *on all values being non boolean, we would need an getIf\n                 *operator in javascript to shorten this :-(\n                 */\n                dest[key] = (UNDEF != typeof dest[key]) ? dest[key] : src[key];\n            } else {\n                dest[key] = (UNDEF != typeof src[key]) ? src[key] : dest[key];\n            }\n        }\n        return dest;\n    }\n\n    /**\n     * generic object arrays like dom definitions to array conversion method which\n     * transforms any object to something array like\n     * @param obj\n     * @param offset\n     * @param pack\n     * @returns an array converted from the object\n     */\n    objToArray<T>(obj: any, offset?: number, pack?: Array<T>): Array<T> {\n        if (!obj) {\n            return pack || null;\n        }\n        //since offset is numeric we cannot use the shortcut due to 0 being false\n        //special condition array delivered no offset no pack\n        if (obj instanceof Array && !offset && !pack)  return obj;\n        let finalOffset = ('undefined' != typeof offset || null != offset) ? offset : 0;\n        let finalPack = pack || [];\n        try {\n            return finalPack.concat(Array.prototype.slice.call(obj, finalOffset));\n        } catch (e) {\n            //ie8 (again as only browser) delivers for css 3 selectors a non convertible object\n            //we have to do it the hard way\n            //ie8 seems generally a little bit strange in its behavior some\n            //objects break the function is everything methodology of javascript\n            //and do not implement apply call, or are pseudo arrays which cannot\n            //be sliced\n            for (let cnt = finalOffset; cnt < obj.length; cnt++) {\n                finalPack.push(obj[cnt]);\n            }\n            return finalPack;\n        }\n    }\n\n    /**\n     * foreach implementation utilizing the\n     * ECMAScript wherever possible\n     * with added functionality\n     *\n     * @param arr the array to filter\n     * @param callbackfn\n     * @param startPos\n     * @param scope the closure to apply the function to, with the syntax defined by the ecmascript functionality\n     * function (element<,key, array>)\n     * <p />\n     * optional params\n     * <p />\n     * <ul>\n     *      <li>param startPos (optional) the starting position </li>\n     *      <li>param scope (optional) the scope to apply the closure to  </li>\n     * </ul>\n     */\n    arrForEach<T>(arr: any, callbackfn: (value: T, index: number, array: T[]) => void, startPos?: number, scope?: Function) {\n        if (!arr || !arr.length) return;\n        let startPosFinal = startPos || 0;\n        let thisObj = scope;\n        //check for an existing foreach mapping on array prototypes\n        //IE9 still does not pass array objects as result for dom ops\n        let convertedArr: Array<T> = this.objToArray<T>(arr);\n        (startPos) ? convertedArr.slice(startPosFinal).forEach(callbackfn, thisObj) : convertedArr.forEach(callbackfn, thisObj);\n    }\n\n    /**\n     * checks if an array contains an element\n     * @param {Array} arr   array\n     * @param {String} str string to check for\n     */\n    contains<T>(arr: T[], str: string) {\n        if (!arr || !str) {\n            throw Error(\"null value on arr or str not allowed\");\n        }\n        return this.arrIndexOf(arr, str) != -1;\n    }\n\n    /**\n     * adds a EcmaScript optimized indexOf to our mix,\n     * checks for the presence of an indexOf functionality\n     * and applies it, otherwise uses a fallback to the hold\n     * loop method to determine the index\n     *\n     * @param arr the array\n     * @param element the index to search for\n     * @param fromIndex\n     */\n    arrIndexOf<T>(arr: any, element: T, fromIndex ?: number): number {\n        if (!arr || !arr.length) return -1;\n        let pos = fromIndex || 0;\n        arr = this.objToArray<T>(arr);\n        return arr.indexOf(element, pos);\n    }\n\n    /**\n     * filter implementation utilizing the\n     * ECMAScript wherever possible\n     * with added functionality\n     *\n     * @param arr the array to filter\n     * @param scope the closure to apply the function to, with the syntax defined by the ecmascript functionality\n     * function (element<,key, array>)\n     * <p />\n     * additional params\n     * <ul>\n     *  <li> startPos (optional) the starting position</li>\n     *  <li> scope (optional) the scope to apply the closure to</li>\n     * </ul>\n     */\n    arrFilter<T>(arr: any, callbackfn: (value: T, index?: number, array?: T[]) => boolean, startPos ?: number, scope ?: Function) {\n        if (!arr || !arr.length) return [];\n        let arrFinal = this.objToArray<T>(arr);\n        return ((startPos) ? arrFinal.slice(startPos).filter(callbackfn, scope) : arrFinal.filter(callbackfn, scope));\n    }\n\n    /**\n     * helper to automatically apply a delivered arguments map or array\n     * to its destination which has a field \"_\"<key> and a full field\n     *\n     * @param dest the destination object\n     * @param args the arguments array or map\n     * @param argNames the argument names to be transferred\n     */\n    /**\n     * helper to automatically apply a delivered arguments map or array\n     * to its destination which has a field \"_\"<key> and a full field\n     *\n     * @param dest the destination object\n     * @param args the arguments array or map\n     * @param argNames the argument names to be transferred\n     */\n    applyArgs<T>(dest: any, args: { [key: string]: T } | Array<T>, argNames?: Array<string>): any {\n        let UDEF = 'undefined';\n        if (argNames) {\n            for (let cnt = 0; cnt < (<Array<T>>args).length; cnt++) {\n                //dest can be null or 0 hence no shortcut\n                if (UDEF != typeof dest[\"_\" + argNames[cnt]]) {\n                    dest[\"_\" + argNames[cnt]] = args[cnt];\n                }\n                if (UDEF != typeof dest[argNames[cnt]]) {\n                    dest[argNames[cnt]] = args[cnt];\n                }\n            }\n        } else {\n            for (let key in args) {\n                if (!args.hasOwnProperty(key)) continue;\n                if (UDEF != typeof dest[\"_\" + key]) {\n                    dest[\"_\" + key] = args[key];\n                }\n                if (UDEF != typeof dest[key]) {\n                    dest[key] = args[key];\n                }\n            }\n        }\n        return dest;\n    }\n\n    /**\n     * equalsIgnoreCase, case insensitive comparison of two strings\n     *\n     * @param source\n     * @param destination\n     */\n    equalsIgnoreCase(source: string, destination: string): boolean {\n        //either both are not set or null\n        if (!source && !destination) {\n            return true;\n        }\n        //source or dest is set while the other is not\n        if (!source || !destination) return false;\n        //in any other case we do a strong string comparison\n        return source.toLowerCase() === destination.toLowerCase();\n    }\n\n    /*\n     * Promise wrappers for timeout and interval\n     */\n    timeout(timeout: number): CancellablePromise {\n        let handler: any = null;\n        return new CancellablePromise((apply: Function, reject: Function) => {\n            handler = setTimeout(() => {\n                apply();\n            }, timeout);\n        }, () => {\n            if (handler) {\n                clearTimeout(handler);\n                handler = null;\n            }\n        });\n    }\n\n\n\n    interval(timeout: number): CancellablePromise {\n        let handler: any = null;\n        return new CancellablePromise((apply: Function, reject: Function) => {\n            handler = setInterval(() => {\n                apply();\n            }, timeout);\n        }, () => {\n            if (handler) {\n                clearInterval(handler);\n                handler = null;\n            }\n        });\n    }\n\n    /**\n     * runtime type assertion\n     *\n     * @param probe the probe to be tested for a type\n     * @param theType the type to be tested for\n     */\n    public assertType(probe: any, theType: any): boolean {\n        return this.isString(theType) ? typeof probe ==  theType : probe instanceof theType;\n    }\n\n    //should be in lang, but for now here to avoid recursive imports, not sure if typescript still has a problem with those\n    /**\n     * helper function to savely resolve anything\n     * this is not an elvis operator, it resolves\n     * a value without exception in a tree and if\n     * it is not resolvable then an optional of\n     * a default value is restored or Optional.empty\n     * if none is given\n     *\n     * usage\n     * <code>\n     *     let var: Optiona<string> = saveResolve(() => a.b.c.d.e, \"foobaz\")\n     * </code>\n     *\n     * @param resolverProducer a lambda which can produce the value\n     * @param defaultValue an optional default value if the producer failes to produce anything\n     * @returns an Optional of the produced value\n     */\n    static saveResolve<T>(resolverProducer: () => T, defaultValue:T = null): Optional<T> {\n        try {\n            let result = resolverProducer();\n            if(\"undefined\" == typeof result || null == result) {\n                return Optional.fromNullable(defaultValue);\n            }\n            return Optional.fromNullable(result);\n        } catch (e) {\n            return Optional.absent;\n        }\n    }\n\n}","import {Optional} from \"./Monad\";\n\n\nexport enum PromiseStatus {\n    PENDING, FULLFILLED, REJECTED\n}\n\nexport interface IPromise {\n    then(executorFunc: (val: any) => any): IPromise;\n\n    catch(executorFunc: (val: any) => any): IPromise\n\n    finally(executorFunc: () => void): IPromise;\n\n}\n\n\n\n/**\n * a small (probably not 100% correct, although I tried to be correct as possible) Promise implementation\n * for systems which do not have a promise implemented\n * Note, although an internal state is kept, this is sideffect free since\n * is value is a function to operate on, hence no real state is kept internally, except for the then\n * and catch calling order\n */\nexport class Promise implements IPromise {\n\n    private value: (resolve: (val?: any) => void, reject: (val?: any) => void) => void;\n\n    status = PromiseStatus.PENDING;\n\n    protected allFuncs: Array<any> = [];\n\n    constructor(executor: (resolve: (val?: any) => void, reject: (val?: any) => void) => void) {\n        //super(executor);\n        this.value = executor;\n        this.value((data: any) => this.resolve(data), (data: any) => this.reject(data));\n    }\n\n    static all(...promises: Array<IPromise>): IPromise {\n\n        let promiseCnt = 0;\n        let myapply: Function;\n\n        let myPromise = new Promise((apply: Function, reject: Function) => {\n            myapply = apply;\n        });\n        let executor = () => {\n            promiseCnt++;\n\n            if (promises.length == promiseCnt) {\n                myapply();\n            }\n        };\n        (<any>executor).__last__ = true;\n\n        for (let cnt = 0; cnt < promises.length; cnt++) {\n            promises[cnt].finally(executor);\n        }\n        return myPromise;\n    }\n\n\n    static race(...promises: Array<IPromise>): IPromise {\n\n        let promiseCnt = 0;\n        let myapply: Function;\n        let myreject: Function;\n\n        let myPromise = new Promise((apply: Function, reject: Function) => {\n            myapply = apply;\n            myreject = reject;\n        });\n\n\n        let thenexecutor = (): IPromise => {\n            if (!!myapply) {\n                myapply();\n            }\n            myapply = null;\n            myreject = null;\n            return null;\n        };\n        (<any>thenexecutor).__last__ = true;\n\n        let catchexeutor = (): IPromise => {\n            if (!!myreject) {\n                myreject();\n            }\n            myreject = null;\n            myapply = null;\n            return null;\n        };\n        (<any>catchexeutor).__last__ = true;\n\n        for (let cnt = 0; cnt < promises.length; cnt++) {\n            promises[cnt].then(thenexecutor);\n            promises[cnt].catch(catchexeutor);\n        }\n        return myPromise;\n    }\n\n    static reject(reason: any): Promise {\n        let retVal = new Promise((resolve: any, reject: any) => {\n            //not really doable without a hack\n            if (reason instanceof Promise) {\n                reason.then((val: any) => {\n                    reject(val);\n                });\n            } else {\n                setTimeout(() => {\n                    reject(reason);\n                }, 1);\n            }\n        });\n\n        return retVal;\n    }\n\n    static resolve(reason: any): Promise {\n        let retVal = new Promise((resolve: any, reject: any) => {\n            //not really doable without a hack\n            if (reason instanceof Promise) {\n                reason.then((val) => resolve(val));\n            } else {\n                setTimeout(() => {\n                    resolve(reason);\n                }, 1);\n            }\n        });\n\n        return retVal;\n\n    }\n\n    then(executorFunc: (val?: any) => any, catchfunc?: (val?: any) => any): Promise {\n        this.allFuncs.push({\"then\": executorFunc});\n        if (catchfunc) {\n            this.allFuncs.push({\"catch\": catchfunc});\n        }\n        this.spliceLastFuncs();\n        return this;\n    }\n\n    catch(executorFunc: (val?: any) => void): Promise {\n        this.allFuncs.push({\"catch\": executorFunc});\n        this.spliceLastFuncs();\n        return this;\n    }\n\n\n    finally(executorFunc: () => void): Promise {\n        if ((<any>this).__reason__) {\n            (<any>this).__reason__.finally(executorFunc);\n            return;\n        }\n\n        this.allFuncs.push({\"finally\": executorFunc});\n        this.spliceLastFuncs();\n        return this;\n    }\n\n    private spliceLastFuncs() {\n        let lastFuncs = [];\n        let rest = [];\n        for (let cnt = 0; cnt < this.allFuncs.length; cnt++) {\n            for (let key in this.allFuncs[cnt]) {\n                if (this.allFuncs[cnt][key].__last__) {\n                    lastFuncs.push(this.allFuncs[cnt]);\n                } else {\n                    rest.push(this.allFuncs[cnt]);\n                }\n            }\n        }\n        this.allFuncs = rest.concat(lastFuncs);\n    }\n\n\n    protected resolve(val?: any) {\n\n\n        while (this.allFuncs.length) {\n            if (!this.allFuncs[0].then) {\n                break;\n            }\n            let fn = this.allFuncs.shift();\n\n            let funcResult = Optional.fromNullable(fn.then(val));\n\n            if (funcResult.isPresent()) {\n                funcResult = funcResult.flatMap();\n                val = funcResult.value;\n                if (val instanceof Promise) {\n                    //var func = (newVal: any) => {this.resolve(newVal)};\n                    //func.__last__  = true;\n                    //val.then(func);\n                    this.transferIntoNewPromise(val);\n\n                    return;\n                }\n            } else {\n                break;\n            }\n        }\n\n        this.appyFinally();\n        this.status = PromiseStatus.FULLFILLED;\n    }\n\n    protected reject(val?: any) {\n\n        while (this.allFuncs.length) {\n            if (this.allFuncs[0].finally) {\n                break;\n            }\n            var fn = this.allFuncs.shift();\n            if (fn.catch) {\n                var funcResult = Optional.fromNullable(fn.catch(val));\n                if (funcResult.isPresent()) {\n                    funcResult = funcResult.flatMap();\n                    val = funcResult.value;\n                    if (val instanceof Promise) {\n                        //val.then((newVal: any) => {this.resolve(newVal)});\n                        this.transferIntoNewPromise(val);\n                        return;\n                    }\n                    this.status = PromiseStatus.REJECTED;\n                    break;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        this.status = PromiseStatus.REJECTED;\n        this.appyFinally();\n    }\n\n    private transferIntoNewPromise(val: any) {\n        for (var cnt = 0; cnt < this.allFuncs.length; cnt++) {\n            for (let key in this.allFuncs[cnt]) {\n                val[key](this.allFuncs[cnt][key]);\n            }\n        }\n    }\n\n    protected appyFinally() {\n        while (this.allFuncs.length) {\n            var fn = this.allFuncs.shift();\n            if (fn.finally) {\n                fn.finally();\n            }\n        }\n    }\n}\n\n/**\n * a cancellable promise\n * a Promise with a cancel function, which can be cancellend any time\n * this is useful for promises which use cancellable asynchronous operations\n * note, even in a cancel state, the finally of the promise is executed, however\n * subsequent thens are not anymore.\n * The current then however is fished or a catch is called depending on how the outer\n * operation reacts to a cancel order.\n */\nexport class CancellablePromise extends Promise {\n\n    private cancellator = () => {\n    };\n\n    /**\n     * @param executor asynchronous callback operation which triggers the callback\n     * @param cancellator cancel operation, separate from the trigger operation\n     */\n    constructor(executor: (resolve: (val?: any) => void, reject: (val?: any) => void) => void, cancellator: () => void) {\n        super(executor);\n        this.cancellator = cancellator;\n    }\n\n    cancel() {\n        this.status = PromiseStatus.REJECTED;\n        this.appyFinally();\n        //lets terminate it once and for all, the finally has been applied\n        this.allFuncs = [];\n    }\n\n\n    then(executorFunc: (val?: any) => any, catchfunc?: (val?: any) => any): CancellablePromise {\n        return <CancellablePromise> super.then(executorFunc, catchfunc);\n    }\n\n    catch(executorFunc: (val?: any) => void): CancellablePromise {\n        return <CancellablePromise> super.catch(executorFunc);\n    }\n\n    finally(executorFunc: () => void): CancellablePromise {\n        return <CancellablePromise> super.finally(executorFunc);\n    }\n}\n\n\n\n"],"sourceRoot":""}