{"version":3,"sources":["../src/main/typescript/Monad.ts"],"names":[],"mappings":"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","file":"Monad-system.js","sourcesContent":["/* Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A module which keeps  basic monadish like definitions in place without any sidedependencies to other modules.\n * Useful if you need the functions in another library to keep its dependencies down\n */\n\n/*IMonad definitions*/\n\n/**\n * IFunctor interface,\n * defines an interface which allows to map a functor\n * via a first order function to another functor\n */\nexport interface IFunctor<T> {\n    map<R>(fn: (data: T) => R): IFunctor<R>;\n}\n\n/**\n * IMonad definition, basically a functor with a flaptmap implementation (flatmap reduces all nested monads after a\n * function call f into a monad with the nesting level of 1\n *\n * flatmap flats nested Monads into a IMonad of the deepest nested implementation\n */\nexport interface IMonad<T, M extends IMonad<any, any>> extends IFunctor<T> {\n    flatMap<T, M>(f: (T) => M): IMonad<any, any>;\n}\n\n/**\n * a stateful functor which holds a value upn which a\n * function can be applied\n *\n * as value holder of type T\n */\nexport interface IIdentity<T> extends IFunctor<T> {\n    readonly value: T;\n}\n\n/**\n *  custom value holder definition, since we are not pure functional\n *  but iterative we have structures which allow the assignment of a value\n *  also not all structures are sideffect free\n */\nexport interface IValueHolder<T> {\n    value: T;\n}\n\n/**\n * Implementation of a monad\n * (Sideffect free), no write allowed directly on the monads\n * value state\n */\nexport class Monad<T> implements IMonad<T, Monad<any>> {\n    protected _value: T;\n\n    constructor(value: T) {\n        this._value = value;\n    }\n\n    map<R>(fn?: (data: T) => R): Monad<R> {\n        if (!fn) {\n            fn = (inval: any) => <R>inval;\n        }\n        let result: R = fn(this.value);\n        return new Monad(result);\n    }\n\n    flatMap<R>(fn?: (data: T) => R): Monad<any> {\n        let mapped: Monad<any> = this.map(fn);\n        while (\"undefined\" != typeof mapped && mapped != null && mapped.value instanceof Monad) {\n            mapped = mapped.value\n        }\n        return mapped;\n    }\n\n\n    get value(): T {\n        return this._value;\n    }\n\n}\n\n\n/**\n * optional implementation, an optional is basically an implementation of a Monad with additional syntactic\n * sugar on top\n * (Sideeffect free, since value assignment is not allowed)\n * */\nexport class Optional<T> extends Monad<T> {\n\n\n    constructor(value: T) {\n        super(value);\n    }\n\n    static fromNullable<T>(value?: T): Optional<T> {\n        return new Optional(value);\n    }\n\n    /*default value for absent*/\n    static absent = Optional.fromNullable(null);\n\n    /*syntactic sugar for absent and present checks*/\n    isAbsent(): boolean {\n        return \"undefined\" == typeof this.value || null == this.value;\n    }\n\n    isPresent(): boolean {\n        return !this.isAbsent();\n    }\n\n    presentOrElse(elseValue: any): Optional<any> {\n        if (this.isPresent()) {\n            return this;\n        } else {\n            return this.flatMap(this.getClass().fromNullable(elseValue));\n        }\n    }\n\n    /*\n     * we need to implement it to fullfill the contract, although it is used only internally\n     * all values are flattened when accessed anyway, so there is no need to call this methiod\n     */\n    flatMap<R>(fn?: (data: T) => R): Optional<any> {\n        var val = super.flatMap(fn);\n        if (!(val instanceof Optional)) {\n            return Optional.fromNullable(val.value);\n        }\n        return <Optional<any>> val.flatMap();\n    }\n\n    /**\n     * additional syntactic sugar which is not part of the usual optional implementation\n     * but makes life easier, if you want to sacrifice typesafety and refactoring\n     * capabilities in typescript\n     */\n    private getIfPresent<R>(key: string): Optional<R> {\n        if (this.isAbsent()) {\n            return this.getClass().absent;\n        }\n        return this.getClass().fromNullable(this.value[key]).flatMap();\n    }\n\n\n    /*\n     * elvis operation, take care, if you use this you lose typesafety and refactoring\n     * capabilites, unfortunately typesceript does not allow to have its own elvis operator\n     * this is some syntactic sugar however which is quite useful*/\n    getIf<R>(...key: string[]): Optional<R> {\n\n        let currentPos: Optional<any> = this;\n        for (let cnt = 0; cnt < key.length; cnt++) {\n            let currKey = this.keyVal(key[cnt]);\n            let arrPos = this.arrayIndex(key[cnt]);\n\n            if (currKey === \"\" && arrPos >= 0) {\n                currentPos = this.getClass().fromNullable(!(currentPos.value instanceof Array ) ? null : (currentPos.value.length < arrPos ? null : currentPos.value[arrPos]));\n                if (currentPos.isAbsent()) {\n                    return currentPos;\n                }\n                continue;\n            } else if (currKey && arrPos >= 0) {\n                if (currentPos.getIfPresent(currKey).isAbsent()) {\n                    return currentPos;\n                }\n                currentPos = (currentPos.getIfPresent(currKey).value instanceof Array) ? this.getClass().fromNullable(currentPos.getIfPresent(currKey).value[arrPos]) : this.getClass().absent;\n                if (currentPos.isAbsent()) {\n                    return currentPos;\n                }\n                continue;\n\n            } else {\n                currentPos = currentPos.getIfPresent(currKey);\n            }\n            if (currentPos.isAbsent()) {\n                return currentPos;\n            } else if (arrPos > -1) {\n                currentPos = this.getClass().fromNullable(currentPos.value[arrPos]);\n            }\n        }\n        let retVal = currentPos;\n\n        return retVal;\n    }\n\n    get value(): T {\n        if (this._value instanceof Monad) {\n            return this._value.flatMap().value\n        }\n        return this._value;\n    }\n\n    /**\n     * convenience function to flatmap the internal value\n     * and replace it with a default in case of being absent\n     *\n     * @param defaultVal\n     * @returns {Optional<any>}\n     */\n    get<R>(defaultVal: any): Optional<R> {\n        if (this.isAbsent()) {\n            return this.getClass().fromNullable(defaultVal).flatMap();\n        }\n\n        return this.getClass().fromNullable(this.value).flatMap();\n    }\n\n    /**\n     * helper to override several implementations in a more fluent way\n     * by having a getClass operation we can avoid direct calls into the constructor or\n     * static methods and do not have to implement several methods which rely on the type\n     * of \"this\"\n     * @returns {Monadish.Optional}\n     */\n    protected getClass(): any {\n        return Optional;\n    }\n\n    toJson(): string {\n        return JSON.stringify(this.value);\n    }\n\n    /*helper method for getIf with array access aka <name>[<indexPos>]*/\n    protected arrayIndex(key: string): number {\n        let start = key.indexOf(\"[\");\n        let end = key.indexOf(\"]\");\n        if (start >= 0 && end > 0 && start < end) {\n            return parseInt(key.substring(start + 1, end));\n        } else {\n            return -1;\n        }\n    }\n\n    /*helper method for getIf with array access aka <name>[<indexPos>]*/\n    protected keyVal(key: string): string {\n        let start = key.indexOf(\"[\");\n\n        if (start >= 0) {\n            return key.substring(0, start);\n        } else {\n            return key;\n        }\n    }\n\n\n}\n\n\n/**\n * helper class to allow write access to the config\n * in certain situations (after an apply call)\n */\nclass ConfigEntry<T> implements IValueHolder<T> {\n    rootElem: any;\n    key: any;\n    arrPos: number;\n\n\n    constructor(rootElem: any, key: any, arrPos?: number) {\n        this.rootElem = rootElem;\n        this.key = key;\n        this.arrPos = (\"undefined\" != typeof arrPos) ? arrPos : -1;\n    }\n\n    get value() {\n        if (this.key == \"\" && this.arrPos >= 0) {\n            return this.rootElem[this.arrPos];\n        } else if (this.key && this.arrPos >= 0) {\n            return this.rootElem[this.key][this.arrPos];\n        }\n        return this.rootElem[this.key];\n    }\n\n    set value(val: T) {\n        if (this.key == \"\" && this.arrPos >= 0) {\n            this.rootElem[this.arrPos] = val;\n            return;\n        } else if (this.key && this.arrPos >= 0) {\n            this.rootElem[this.key][this.arrPos] = val;\n            return;\n        }\n        this.rootElem[this.key] = val;\n    }\n}\n\n/**\n * Config, basically an optional wrapper for a json structure\n * (not sideeffect free, since we can alter the internal config state\n * without generating a new config), not sure if we should make it sideffect free\n * since this would swallow a lot of performane and ram\n */\nexport class Config extends Optional<any> {\n    constructor(root: any) {\n        super(root);\n    }\n\n    static fromNullable<T>(value?: any): Config {\n        return new Config(value);\n    }\n\n    apply(...keys: Array<any>): IValueHolder<any> {\n        if (keys.length < 1) {\n            return;\n        }\n\n        this.buildPath(keys);\n\n        let currKey = this.keyVal(keys[keys.length - 1]);\n        let arrPos = this.arrayIndex(keys[keys.length - 1]);\n        var retVal = new ConfigEntry(keys.length == 1 ? this.value : this.getIf.apply(this, keys.slice(0, keys.length - 1)).value,\n            currKey, arrPos\n        );\n\n        return retVal;\n    }\n\n\n    getIf(...keys: Array<string>): Config {\n        return this.getClass().fromNullable(super.getIf.apply(this, keys).value);\n    }\n\n    get(defaultVal: any): Config {\n        return this.getClass().fromNullable(super.get(defaultVal).value);\n    }\n\n    toJson(): any {\n        return JSON.stringify(this.value);\n    }\n\n    protected getClass(): any {\n        return Config;\n    }\n\n    private setVal(val: any) {\n        this._value = val;\n    }\n\n    private buildPath(keys: Array<any>): Config {\n        let val = this;\n        let parentVal = this.getClass().fromNullable(null);\n        let parentPos = -1;\n        let alloc = function (arr: Array<any>, length: number) {\n            if (arr.length < length) {\n                for (var cnt = arr.length; cnt < length; cnt++) {\n                    arr.push({});\n                }\n            }\n        };\n\n\n        for (var cnt = 0; cnt < keys.length; cnt++) {\n            let currKey = this.keyVal(keys[cnt]);\n            let arrPos = this.arrayIndex(keys[cnt]);\n\n            if (currKey === \"\" && arrPos >= 0) {\n\n                val.setVal((val.value instanceof Array) ? val.value : []);\n                alloc(val.value, arrPos + 1);\n                if (parentPos >= 0) {\n                    parentVal.value[parentPos] = val.value;\n                }\n                parentVal = val;\n                parentPos = arrPos;\n                val = this.getClass().fromNullable(val.value[arrPos]);\n                continue;\n            }\n\n            let tempVal = <Config> val.getIf(currKey);\n            if (arrPos == -1) {\n                if (tempVal.isAbsent()) {\n                    tempVal = <Config> this.getClass().fromNullable(val.value[currKey] = {});\n                } else {\n                    val = <any>tempVal;\n                }\n            } else {\n                var arr = (tempVal.value instanceof Array) ? tempVal.value : [];\n                alloc(arr, arrPos + 1);\n                val.value[currKey] = arr;\n                tempVal = this.getClass().fromNullable(arr[arrPos]);\n            }\n            parentVal = val;\n            parentPos = arrPos;\n            val = <any>tempVal;\n        }\n\n        return this;\n    }\n}\n\n\nexport enum PromiseStatus {\n    PENDING, FULLFILLED, REJECTED\n}\n\nexport interface IPromise {\n    then(executorFunc: (val: any) => any): IPromise;\n\n    catch(executorFunc: (val: any) => any): IPromise\n\n    finally(executorFunc: () => void): IPromise;\n\n}\n\n/**\n * a small (probably not 100% correct, although I tried to be correct as possible) Promise implementation\n * for systems which do not have a promise implemented\n * Note, although an internal state is kept, this is sideffect free since\n * is value is a function to operate on, hence no real state is kept internally, except for the then\n * and catch calling order\n */\nexport class Promise implements IPromise {\n\n    private value: (resolve: (val?: any) => void, reject: (val?: any) => void) => void;\n\n    status = PromiseStatus.PENDING;\n\n    protected allFuncs: Array<any> = [];\n\n    constructor(executor: (resolve: (val?: any) => void, reject: (val?: any) => void) => void) {\n        //super(executor);\n        this.value = executor;\n        this.value((data: any) => this.resolve(data), (data: any) => this.reject(data));\n    }\n\n    static all(...promises: Array<IPromise>): IPromise {\n\n        var promiseCnt = 0;\n        var myapply: Function;\n\n        var myPromise = new Promise((apply: Function, reject: Function) => {\n            myapply = apply;\n        });\n        var executor = () => {\n            promiseCnt++;\n\n            if (promises.length == promiseCnt) {\n                myapply();\n            }\n        };\n        (<any>executor).__last__ = true;\n\n        for (var cnt = 0; cnt < promises.length; cnt++) {\n            promises[cnt].finally(executor);\n        }\n        return myPromise;\n    }\n\n\n    static race(...promises: Array<IPromise>): IPromise {\n\n        var promiseCnt = 0;\n        var myapply: Function;\n        var myreject: Function;\n\n        var myPromise = new Promise((apply: Function, reject: Function) => {\n            myapply = apply;\n            myreject = reject;\n        });\n\n\n        var thenexecutor = (): IPromise => {\n            if (!!myapply) {\n                myapply();\n            }\n            myapply = null;\n            myreject = null;\n            return null;\n        };\n        (<any>thenexecutor).__last__ = true;\n\n        var catchexeutor = (): IPromise => {\n            if (!!myreject) {\n                myreject();\n            }\n            myreject = null;\n            myapply = null;\n            return null;\n        };\n        (<any>catchexeutor).__last__ = true;\n\n        for (var cnt = 0; cnt < promises.length; cnt++) {\n            promises[cnt].then(thenexecutor);\n            promises[cnt].catch(catchexeutor);\n        }\n        return myPromise;\n    }\n\n    static reject(reason: any): Promise {\n        var retVal = new Promise((resolve: any, reject: any) => {\n            //not really doable without a hack\n            if (reason instanceof Promise) {\n                reason.then((val: any) => {\n                    reject(val);\n                });\n            } else {\n                setTimeout(() => {\n                    reject(reason);\n                }, 1);\n            }\n        });\n\n        return retVal;\n    }\n\n    static resolve(reason: any): Promise {\n        var retVal = new Promise((resolve: any, reject: any) => {\n            //not really doable without a hack\n            if (reason instanceof Promise) {\n                reason.then((val) => resolve(val));\n            } else {\n                setTimeout(() => {\n                    resolve(reason);\n                }, 1);\n            }\n        });\n\n        return retVal;\n\n    }\n\n    then(executorFunc: (val?: any) => any, catchfunc?: (val?: any) => any): Promise {\n        this.allFuncs.push({\"then\": executorFunc});\n        if (catchfunc) {\n            this.allFuncs.push({\"catch\": catchfunc});\n        }\n        this.spliceLastFuncs();\n        return this;\n    }\n\n    catch(executorFunc: (val?: any) => void): Promise {\n        this.allFuncs.push({\"catch\": executorFunc});\n        this.spliceLastFuncs();\n        return this;\n    }\n\n\n    finally(executorFunc: () => void): Promise {\n        if ((<any>this).__reason__) {\n            (<any>this).__reason__.finally(executorFunc);\n            return;\n        }\n\n        this.allFuncs.push({\"finally\": executorFunc});\n        this.spliceLastFuncs();\n        return this;\n    }\n\n    private spliceLastFuncs() {\n        let lastFuncs = [];\n        let rest = [];\n        for (var cnt = 0; cnt < this.allFuncs.length; cnt++) {\n            for (var key in this.allFuncs[cnt]) {\n                if (this.allFuncs[cnt][key].__last__) {\n                    lastFuncs.push(this.allFuncs[cnt]);\n                } else {\n                    rest.push(this.allFuncs[cnt]);\n                }\n            }\n        }\n        this.allFuncs = rest.concat(lastFuncs);\n    }\n\n\n    protected resolve(val?: any) {\n\n\n        while (this.allFuncs.length) {\n            if (!this.allFuncs[0].then) {\n                break;\n            }\n            var fn = this.allFuncs.shift();\n\n            var funcResult = Optional.fromNullable(fn.then(val));\n\n            if (funcResult.isPresent()) {\n                funcResult = funcResult.flatMap();\n                val = funcResult.value;\n                if (val instanceof Promise) {\n                    //var func = (newVal: any) => {this.resolve(newVal)};\n                    //func.__last__  = true;\n                    //val.then(func);\n                    this.transferIntoNewPromise(val);\n\n                    return;\n                }\n            } else {\n                break;\n            }\n        }\n\n        this.appyFinally();\n        this.status = PromiseStatus.FULLFILLED;\n    }\n\n    protected reject(val?: any) {\n\n        while (this.allFuncs.length) {\n            if (this.allFuncs[0].finally) {\n                break;\n            }\n            var fn = this.allFuncs.shift();\n            if (fn.catch) {\n                var funcResult = Optional.fromNullable(fn.catch(val));\n                if (funcResult.isPresent()) {\n                    funcResult = funcResult.flatMap();\n                    val = funcResult.value;\n                    if (val instanceof Promise) {\n                        //val.then((newVal: any) => {this.resolve(newVal)});\n                        this.transferIntoNewPromise(val);\n                        return;\n                    }\n                    this.status = PromiseStatus.REJECTED;\n                    break;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        this.status = PromiseStatus.REJECTED;\n        this.appyFinally();\n    }\n\n    private transferIntoNewPromise(val: any) {\n        for (var cnt = 0; cnt < this.allFuncs.length; cnt++) {\n            for (let key in this.allFuncs[cnt]) {\n                val[key](this.allFuncs[cnt][key]);\n            }\n        }\n    }\n\n    protected appyFinally() {\n        while (this.allFuncs.length) {\n            var fn = this.allFuncs.shift();\n            if (fn.finally) {\n                fn.finally();\n            }\n        }\n    }\n}\n\n/**\n * a cancellable promise\n * a Promise with a cancel function, which can be cancellend any time\n * this is useful for promises which use cancellable asynchronous operations\n * note, even in a cancel state, the finally of the promise is executed, however\n * subsequent thens are not anymore.\n * The current then however is fished or a catch is called depending on how the outer\n * operation reacts to a cancel order.\n */\nexport class CancellablePromise extends Promise {\n\n    private cancellator = () => {\n    };\n\n    /**\n     * @param executor asynchronous callback operation which triggers the callback\n     * @param cancellator cancel operation, separate from the trigger operation\n     */\n    constructor(executor: (resolve: (val?: any) => void, reject: (val?: any) => void) => void, cancellator: () => void) {\n        super(executor);\n        this.cancellator = cancellator;\n    }\n\n    cancel() {\n        this.status = PromiseStatus.REJECTED;\n        this.appyFinally();\n        //lets terminate it once and for all, the finally has been applied\n        this.allFuncs = [];\n    }\n\n\n    then(executorFunc: (val?: any) => any, catchfunc?: (val?: any) => any): CancellablePromise {\n        return <CancellablePromise> super.then(executorFunc, catchfunc);\n    }\n\n    catch(executorFunc: (val?: any) => void): CancellablePromise {\n        return <CancellablePromise> super.catch(executorFunc);\n    }\n\n    finally(executorFunc: () => void): CancellablePromise {\n        return <CancellablePromise> super.finally(executorFunc);\n    }\n}\n\n/*we do not implenent array, maps etc.. monads there are libraries like lodash which have been doing that for ages*/\n\n"]}