{"version":3,"names":[],"mappings":"","sources":["Monad.js"],"sourcesContent":["/* Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * A module which keeps  basic monadish like definitions in place without any sidedependencies to other modules.\n     * Useful if you need the functions in another library to keep its dependencies down\n     */\n    var Monadish;\n    (function (Monadish) {\n        /*IMonad definitions*/\n        /**\n         * Implementation of a monad\n         * (Sideffect free), no write allowed directly on the monads\n         * value state\n         */\n        var Monad = (function () {\n            function Monad(value) {\n                this._value = value;\n            }\n            Monad.prototype.map = function (fn) {\n                if (!fn) {\n                    fn = function (inval) { return inval; };\n                }\n                var result = fn(this.value);\n                return new Monad(result);\n            };\n            Monad.prototype.flatMap = function (fn) {\n                var mapped = this.map(fn);\n                while (\"undefined\" != typeof mapped && mapped != null && mapped.value instanceof Monad) {\n                    mapped = mapped.value;\n                }\n                return mapped;\n            };\n            Object.defineProperty(Monad.prototype, \"value\", {\n                get: function () {\n                    return this._value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return Monad;\n        }());\n        Monadish.Monad = Monad;\n        /**\n         * optional implementation, an optional is basically an implementation of a Monad with additional syntactic\n         * sugar on top\n         * (Sideeffect free, since value assignment is not allowed)\n         * */\n        var Optional = (function (_super) {\n            __extends(Optional, _super);\n            function Optional(value) {\n                return _super.call(this, value) || this;\n            }\n            Optional.fromNullable = function (value) {\n                return new Optional(value);\n            };\n            /*syntactic sugar for absent and present checks*/\n            Optional.prototype.isAbsent = function () {\n                return \"undefined\" == typeof this.value || null == this.value;\n            };\n            Optional.prototype.isPresent = function () {\n                return !this.isAbsent();\n            };\n            Optional.prototype.presentOrElse = function (elseValue) {\n                if (this.isPresent()) {\n                    return this;\n                }\n                else {\n                    return this.flatMap(this.getClass().fromNullable(elseValue));\n                }\n            };\n            /*\n             * we need to implement it to fullfill the contract, although it is used only internally\n             * all values are flattened when accessed anyway, so there is no need to call this methiod\n             */\n            Optional.prototype.flatMap = function (fn) {\n                var val = _super.prototype.flatMap.call(this, fn);\n                if (!(val instanceof Optional)) {\n                    return Optional.fromNullable(val.value);\n                }\n                return val.flatMap();\n            };\n            /**\n             * additional syntactic sugar which is not part of the usual optional implementation\n             * but makes life easier, if you want to sacrifice typesafety and refactoring\n             * capabilities in typescript\n             */\n            Optional.prototype.getIfPresent = function (key) {\n                if (this.isAbsent()) {\n                    return this.getClass().absent;\n                }\n                return this.getClass().fromNullable(this.value[key]).flatMap();\n            };\n            /*\n             * elvis operation, take care, if you use this you lose typesafety and refactoring\n             * capabilites, unfortunately typesceript does not allow to have its own elvis operator\n             * this is some syntactic sugar however which is quite useful*/\n            Optional.prototype.getIf = function () {\n                var key = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    key[_i] = arguments[_i];\n                }\n                var currentPos = this;\n                for (var cnt = 0; cnt < key.length; cnt++) {\n                    var currKey = this.keyVal(key[cnt]);\n                    var arrPos = this.arrayIndex(key[cnt]);\n                    if (currKey === \"\" && arrPos >= 0) {\n                        currentPos = this.getClass().fromNullable(!(currentPos.value instanceof Array) ? null : (currentPos.value.length < arrPos ? null : currentPos.value[arrPos]));\n                        if (currentPos.isAbsent()) {\n                            return currentPos;\n                        }\n                        continue;\n                    }\n                    else if (currKey && arrPos >= 0) {\n                        if (currentPos.getIfPresent(currKey).isAbsent()) {\n                            return currentPos;\n                        }\n                        currentPos = (currentPos.getIfPresent(currKey).value instanceof Array) ? this.getClass().fromNullable(currentPos.getIfPresent(currKey).value[arrPos]) : this.getClass().absent;\n                        if (currentPos.isAbsent()) {\n                            return currentPos;\n                        }\n                        continue;\n                    }\n                    else {\n                        currentPos = currentPos.getIfPresent(currKey);\n                    }\n                    if (currentPos.isAbsent()) {\n                        return currentPos;\n                    }\n                    else if (arrPos > -1) {\n                        currentPos = this.getClass().fromNullable(currentPos.value[arrPos]);\n                    }\n                }\n                var retVal = currentPos;\n                return retVal;\n            };\n            Object.defineProperty(Optional.prototype, \"value\", {\n                get: function () {\n                    if (this._value instanceof Monad) {\n                        return this._value.flatMap().value;\n                    }\n                    return this._value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            /**\n             * convenience function to flatmap the internal value\n             * and replace it with a default in case of being absent\n             *\n             * @param defaultVal\n             * @returns {Optional<any>}\n             */\n            Optional.prototype.get = function (defaultVal) {\n                if (this.isAbsent()) {\n                    return this.getClass().fromNullable(defaultVal).flatMap();\n                }\n                return this.getClass().fromNullable(this.value).flatMap();\n            };\n            /**\n             * helper to override several implementations in a more fluent way\n             * by having a getClass operation we can avoid direct calls into the constructor or\n             * static methods and do not have to implement several methods which rely on the type\n             * of \"this\"\n             * @returns {Monadish.Optional}\n             */\n            Optional.prototype.getClass = function () {\n                return Optional;\n            };\n            Optional.prototype.toJson = function () {\n                return JSON.stringify(this.value);\n            };\n            /*helper method for getIf with array access aka <name>[<indexPos>]*/\n            Optional.prototype.arrayIndex = function (key) {\n                var start = key.indexOf(\"[\");\n                var end = key.indexOf(\"]\");\n                if (start >= 0 && end > 0 && start < end) {\n                    return parseInt(key.substring(start + 1, end));\n                }\n                else {\n                    return -1;\n                }\n            };\n            /*helper method for getIf with array access aka <name>[<indexPos>]*/\n            Optional.prototype.keyVal = function (key) {\n                var start = key.indexOf(\"[\");\n                if (start >= 0) {\n                    return key.substring(0, start);\n                }\n                else {\n                    return key;\n                }\n            };\n            return Optional;\n        }(Monad));\n        /*default value for absent*/\n        Optional.absent = Optional.fromNullable(null);\n        Monadish.Optional = Optional;\n        /**\n         * helper class to allow write access to the config\n         * in certain situations (after an apply call)\n         */\n        var ConfigEntry = (function () {\n            function ConfigEntry(rootElem, key, arrPos) {\n                this.rootElem = rootElem;\n                this.key = key;\n                this.arrPos = (\"undefined\" != typeof arrPos) ? arrPos : -1;\n            }\n            Object.defineProperty(ConfigEntry.prototype, \"value\", {\n                get: function () {\n                    if (this.key == \"\" && this.arrPos >= 0) {\n                        return this.rootElem[this.arrPos];\n                    }\n                    else if (this.key && this.arrPos >= 0) {\n                        return this.rootElem[this.key][this.arrPos];\n                    }\n                    return this.rootElem[this.key];\n                },\n                set: function (val) {\n                    if (this.key == \"\" && this.arrPos >= 0) {\n                        this.rootElem[this.arrPos] = val;\n                        return;\n                    }\n                    else if (this.key && this.arrPos >= 0) {\n                        this.rootElem[this.key][this.arrPos] = val;\n                        return;\n                    }\n                    this.rootElem[this.key] = val;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return ConfigEntry;\n        }());\n        /**\n         * Config, basically an optional wrapper for a json structure\n         * (not sideeffect free, since we can alter the internal config state\n         * without generating a new config), not sure if we should make it sideffect free\n         * since this would swallow a lot of performane and ram\n         */\n        var Config = (function (_super) {\n            __extends(Config, _super);\n            function Config(root) {\n                return _super.call(this, root) || this;\n            }\n            Config.fromNullable = function (value) {\n                return new Config(value);\n            };\n            Config.prototype.apply = function () {\n                var keys = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    keys[_i] = arguments[_i];\n                }\n                if (keys.length < 1) {\n                    return;\n                }\n                this.buildPath(keys);\n                var currKey = this.keyVal(keys[keys.length - 1]);\n                var arrPos = this.arrayIndex(keys[keys.length - 1]);\n                var retVal = new ConfigEntry(keys.length == 1 ? this.value : this.getIf.apply(this, keys.slice(0, keys.length - 1)).value, currKey, arrPos);\n                return retVal;\n            };\n            Config.prototype.getIf = function () {\n                var keys = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    keys[_i] = arguments[_i];\n                }\n                return this.getClass().fromNullable(_super.prototype.getIf.apply(this, keys).value);\n            };\n            Config.prototype.get = function (defaultVal) {\n                return this.getClass().fromNullable(_super.prototype.get.call(this, defaultVal).value);\n            };\n            Config.prototype.toJson = function () {\n                return JSON.stringify(this.value);\n            };\n            Config.prototype.getClass = function () {\n                return Config;\n            };\n            Config.prototype.setVal = function (val) {\n                this._value = val;\n            };\n            Config.prototype.buildPath = function (keys) {\n                var val = this;\n                var parentVal = this.getClass().fromNullable(null);\n                var parentPos = -1;\n                var alloc = function (arr, length) {\n                    if (arr.length < length) {\n                        for (var cnt = arr.length; cnt < length; cnt++) {\n                            arr.push({});\n                        }\n                    }\n                };\n                for (var cnt = 0; cnt < keys.length; cnt++) {\n                    var currKey = this.keyVal(keys[cnt]);\n                    var arrPos = this.arrayIndex(keys[cnt]);\n                    if (currKey === \"\" && arrPos >= 0) {\n                        val.setVal((val.value instanceof Array) ? val.value : []);\n                        alloc(val.value, arrPos + 1);\n                        if (parentPos >= 0) {\n                            parentVal.value[parentPos] = val.value;\n                        }\n                        parentVal = val;\n                        parentPos = arrPos;\n                        val = this.getClass().fromNullable(val.value[arrPos]);\n                        continue;\n                    }\n                    var tempVal = val.getIf(currKey);\n                    if (arrPos == -1) {\n                        if (tempVal.isAbsent()) {\n                            tempVal = this.getClass().fromNullable(val.value[currKey] = {});\n                        }\n                        else {\n                            val = tempVal;\n                        }\n                    }\n                    else {\n                        var arr = (tempVal.value instanceof Array) ? tempVal.value : [];\n                        alloc(arr, arrPos + 1);\n                        val.value[currKey] = arr;\n                        tempVal = this.getClass().fromNullable(arr[arrPos]);\n                    }\n                    parentVal = val;\n                    parentPos = arrPos;\n                    val = tempVal;\n                }\n                return this;\n            };\n            return Config;\n        }(Optional));\n        Monadish.Config = Config;\n        var PromiseStatus;\n        (function (PromiseStatus) {\n            PromiseStatus[PromiseStatus[\"PENDING\"] = 0] = \"PENDING\";\n            PromiseStatus[PromiseStatus[\"FULLFILLED\"] = 1] = \"FULLFILLED\";\n            PromiseStatus[PromiseStatus[\"REJECTED\"] = 2] = \"REJECTED\";\n        })(PromiseStatus || (PromiseStatus = {}));\n        /**\n         * a small (probably not 100% correct, although I tried to be correct as possible) Promise implementation\n         * for systems which do not have a promise implemented\n         * Note, although an internal state is kept, this is sideffect free since\n         * is value is a function to operate on, hence no real state is kept internally, except for the then\n         * and catch calling order\n         */\n        var Promise = (function () {\n            function Promise(executor) {\n                var _this = this;\n                this.status = PromiseStatus.PENDING;\n                this.allFuncs = [];\n                //super(executor);\n                this.value = executor;\n                this.value(function (data) { return _this.resolve(data); }, function (data) { return _this.reject(data); });\n            }\n            Promise.all = function () {\n                var promises = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    promises[_i] = arguments[_i];\n                }\n                var promiseCnt = 0;\n                var myapply;\n                var myPromise = new Promise(function (apply, reject) {\n                    myapply = apply;\n                });\n                var executor = function () {\n                    promiseCnt++;\n                    if (promises.length == promiseCnt) {\n                        myapply();\n                    }\n                };\n                executor.__last__ = true;\n                for (var cnt = 0; cnt < promises.length; cnt++) {\n                    promises[cnt].finally(executor);\n                }\n                return myPromise;\n            };\n            Promise.race = function () {\n                var promises = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    promises[_i] = arguments[_i];\n                }\n                var promiseCnt = 0;\n                var myapply;\n                var myreject;\n                var myPromise = new Promise(function (apply, reject) {\n                    myapply = apply;\n                    myreject = reject;\n                });\n                var thenexecutor = function () {\n                    if (!!myapply) {\n                        myapply();\n                    }\n                    myapply = null;\n                    myreject = null;\n                    return null;\n                };\n                thenexecutor.__last__ = true;\n                var catchexeutor = function () {\n                    if (!!myreject) {\n                        myreject();\n                    }\n                    myreject = null;\n                    myapply = null;\n                    return null;\n                };\n                catchexeutor.__last__ = true;\n                for (var cnt = 0; cnt < promises.length; cnt++) {\n                    promises[cnt].then(thenexecutor);\n                    promises[cnt].catch(catchexeutor);\n                }\n                return myPromise;\n            };\n            Promise.reject = function (reason) {\n                var retVal = new Promise(function (resolve, reject) {\n                    //not really doable without a hack\n                    if (reason instanceof Promise) {\n                        reason.then(function (val) {\n                            reject(val);\n                        });\n                    }\n                    else {\n                        setTimeout(function () {\n                            reject(reason);\n                        }, 1);\n                    }\n                });\n                return retVal;\n            };\n            Promise.resolve = function (reason) {\n                var retVal = new Promise(function (resolve, reject) {\n                    //not really doable without a hack\n                    if (reason instanceof Promise) {\n                        reason.then(function (val) { return resolve(val); });\n                    }\n                    else {\n                        setTimeout(function () {\n                            resolve(reason);\n                        }, 1);\n                    }\n                });\n                return retVal;\n            };\n            Promise.prototype.then = function (executorFunc, catchfunc) {\n                this.allFuncs.push({ \"then\": executorFunc });\n                if (catchfunc) {\n                    this.allFuncs.push({ \"catch\": catchfunc });\n                }\n                this.spliceLastFuncs();\n                return this;\n            };\n            Promise.prototype.catch = function (executorFunc) {\n                this.allFuncs.push({ \"catch\": executorFunc });\n                this.spliceLastFuncs();\n                return this;\n            };\n            Promise.prototype.finally = function (executorFunc) {\n                if (this.__reason__) {\n                    this.__reason__.finally(executorFunc);\n                    return;\n                }\n                this.allFuncs.push({ \"finally\": executorFunc });\n                this.spliceLastFuncs();\n                return this;\n            };\n            Promise.prototype.spliceLastFuncs = function () {\n                var lastFuncs = [];\n                var rest = [];\n                for (var cnt = 0; cnt < this.allFuncs.length; cnt++) {\n                    for (var key in this.allFuncs[cnt]) {\n                        if (this.allFuncs[cnt][key].__last__) {\n                            lastFuncs.push(this.allFuncs[cnt]);\n                        }\n                        else {\n                            rest.push(this.allFuncs[cnt]);\n                        }\n                    }\n                }\n                this.allFuncs = rest.concat(lastFuncs);\n            };\n            Promise.prototype.resolve = function (val) {\n                while (this.allFuncs.length) {\n                    if (!this.allFuncs[0].then) {\n                        break;\n                    }\n                    var fn = this.allFuncs.shift();\n                    var funcResult = Optional.fromNullable(fn.then(val));\n                    if (funcResult.isPresent()) {\n                        funcResult = funcResult.flatMap();\n                        val = funcResult.value;\n                        if (val instanceof Promise) {\n                            //var func = (newVal: any) => {this.resolve(newVal)};\n                            //func.__last__  = true;\n                            //val.then(func);\n                            this.transferIntoNewPromise(val);\n                            return;\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n                this.appyFinally();\n                this.status = PromiseStatus.FULLFILLED;\n            };\n            Promise.prototype.reject = function (val) {\n                while (this.allFuncs.length) {\n                    if (this.allFuncs[0].finally) {\n                        break;\n                    }\n                    var fn = this.allFuncs.shift();\n                    if (fn.catch) {\n                        var funcResult = Optional.fromNullable(fn.catch(val));\n                        if (funcResult.isPresent()) {\n                            funcResult = funcResult.flatMap();\n                            val = funcResult.value;\n                            if (val instanceof Promise) {\n                                //val.then((newVal: any) => {this.resolve(newVal)});\n                                this.transferIntoNewPromise(val);\n                                return;\n                            }\n                            this.status = PromiseStatus.REJECTED;\n                            break;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n                this.status = PromiseStatus.REJECTED;\n                this.appyFinally();\n            };\n            Promise.prototype.transferIntoNewPromise = function (val) {\n                for (var cnt = 0; cnt < this.allFuncs.length; cnt++) {\n                    for (var key in this.allFuncs[cnt]) {\n                        val[key](this.allFuncs[cnt][key]);\n                    }\n                }\n            };\n            Promise.prototype.appyFinally = function () {\n                while (this.allFuncs.length) {\n                    var fn = this.allFuncs.shift();\n                    if (fn.finally) {\n                        fn.finally();\n                    }\n                }\n            };\n            return Promise;\n        }());\n        Monadish.Promise = Promise;\n        /**\n         * a cancellable promise\n         * a Promise with a cancel function, which can be cancellend any time\n         * this is useful for promises which use cancellable asynchronous operations\n         * note, even in a cancel state, the finally of the promise is executed, however\n         * subsequent thens are not anymore.\n         * The current then however is fished or a catch is called depending on how the outer\n         * operation reacts to a cancel order.\n         */\n        var CancellablePromise = (function (_super) {\n            __extends(CancellablePromise, _super);\n            /**\n             * @param executor asynchronous callback operation which triggers the callback\n             * @param cancellator cancel operation, separate from the trigger operation\n             */\n            function CancellablePromise(executor, cancellator) {\n                var _this = _super.call(this, executor) || this;\n                _this.cancellator = function () { };\n                _this.cancellator = cancellator;\n                return _this;\n            }\n            CancellablePromise.prototype.cancel = function () {\n                this.status = PromiseStatus.REJECTED;\n                this.appyFinally();\n                //lets terminate it once and for all, the finally has been applied\n                this.allFuncs = [];\n            };\n            CancellablePromise.prototype.then = function (executorFunc, catchfunc) {\n                return _super.prototype.then.call(this, executorFunc, catchfunc);\n            };\n            CancellablePromise.prototype.catch = function (executorFunc) {\n                return _super.prototype.catch.call(this, executorFunc);\n            };\n            CancellablePromise.prototype.finally = function (executorFunc) {\n                return _super.prototype.finally.call(this, executorFunc);\n            };\n            return CancellablePromise;\n        }(Promise));\n        Monadish.CancellablePromise = CancellablePromise;\n        /*we do not implenent array, maps etc.. monads there are libraries like lodash which have been doing that for ages*/\n    })(Monadish = exports.Monadish || (exports.Monadish = {}));\n    //we also add a global handler for systems without module loader\n    window.Monadish = Monadish;\n});\n\n//# sourceMappingURL=Monad.js.map\n"],"file":"Monad-bundle.js"}